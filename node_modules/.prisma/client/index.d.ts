
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/index';
declare const prisma: unique symbol
export type PrismaPromise<A> = Promise<A> & {[prisma]: true}
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};


/**
 * Model Producto
 * 
 */
export type Producto = {
  id: number
  nombre: string
  precio: number
  unidadMedida: string
  stock: number
  imagen: string
}

/**
 * Model Usuario
 * 
 */
export type Usuario = {
  id: number
  nombre: string
  dni: string
  correo: string
  password: string
  telefono: string
}

/**
 * Model Direccion
 * 
 */
export type Direccion = {
  id: number
  calle: string
  numero: string
  dpt: string
  ciudad: string
  provincia: string
  referencia: string | null
  usuarioId: number
}

/**
 * Model Pedido
 * 
 */
export type Pedido = {
  id: number
  montoTotal: number
  numeroSeguimiento: string | null
  estado: PedidoEstado
  fecha: Date
  direccionId: number
  usuarioId: number
}

/**
 * Model DetallePedido
 * 
 */
export type DetallePedido = {
  id: number
  precio: number
  cantidad: number
  productoId: number
  pedidoId: number
}

/**
 * Model PedidoEvento
 * 
 */
export type PedidoEvento = {
  id: number
  titulo: PedidoEstado
  fecha: Date
  pedidoId: number
}


/**
 * Enums
 */

// Based on
// https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

export const PedidoEstado: {
  PAGADO: 'PAGADO',
  CANCELADO: 'CANCELADO',
  ENVIADO: 'ENVIADO',
  RECIBIDO: 'RECIBIDO'
};

export type PedidoEstado = (typeof PedidoEstado)[keyof typeof PedidoEstado]


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Productos
 * const productos = await prisma.producto.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
      /**
       * @private
       */
      private fetcher;
      /**
       * @private
       */
      private readonly dmmf;
      /**
       * @private
       */
      private connectionPromise?;
      /**
       * @private
       */
      private disconnectionPromise?;
      /**
       * @private
       */
      private readonly engineConfig;
      /**
       * @private
       */
      private readonly measurePerformance;

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Productos
   * const productos = await prisma.producto.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<UnwrapTuple<P>>;

      /**
   * `prisma.producto`: Exposes CRUD operations for the **Producto** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Productos
    * const productos = await prisma.producto.findMany()
    * ```
    */
  get producto(): Prisma.ProductoDelegate<GlobalReject>;

  /**
   * `prisma.usuario`: Exposes CRUD operations for the **Usuario** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Usuarios
    * const usuarios = await prisma.usuario.findMany()
    * ```
    */
  get usuario(): Prisma.UsuarioDelegate<GlobalReject>;

  /**
   * `prisma.direccion`: Exposes CRUD operations for the **Direccion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Direccions
    * const direccions = await prisma.direccion.findMany()
    * ```
    */
  get direccion(): Prisma.DireccionDelegate<GlobalReject>;

  /**
   * `prisma.pedido`: Exposes CRUD operations for the **Pedido** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pedidos
    * const pedidos = await prisma.pedido.findMany()
    * ```
    */
  get pedido(): Prisma.PedidoDelegate<GlobalReject>;

  /**
   * `prisma.detallePedido`: Exposes CRUD operations for the **DetallePedido** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DetallePedidos
    * const detallePedidos = await prisma.detallePedido.findMany()
    * ```
    */
  get detallePedido(): Prisma.DetallePedidoDelegate<GlobalReject>;

  /**
   * `prisma.pedidoEvento`: Exposes CRUD operations for the **PedidoEvento** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PedidoEventos
    * const pedidoEventos = await prisma.pedidoEvento.findMany()
    * ```
    */
  get pedidoEvento(): Prisma.PedidoEventoDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export import Metrics = runtime.Metrics
  export import Metric = runtime.Metric
  export import MetricHistogram = runtime.MetricHistogram
  export import MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
   * Prisma Client JS version: 4.4.0
   * Query Engine version: f352a33b70356f46311da8b00d83386dd9f145d6
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = {
    [key in keyof T]: T[key] extends false | undefined | null ? never : key
  }[keyof T]

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Exact<A, W = unknown> = 
  W extends unknown ? A extends Narrowable ? Cast<A, W> : Cast<
  {[K in keyof A]: K extends keyof W ? Exact<A[K], W[K]> : never},
  {[K in keyof W]: K extends keyof A ? Exact<A[K], W[K]> : W[K]}>
  : never;

  type Narrowable = string | number | boolean | bigint;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: Exact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export import FieldRef = runtime.FieldRef

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>

  class PrismaClientFetcher {
    private readonly prisma;
    private readonly debug;
    private readonly hooks?;
    constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
    request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
    sanitizeMessage(message: string): string;
    protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
  }

  export const ModelName: {
    Producto: 'Producto',
    Usuario: 'Usuario',
    Direccion: 'Direccion',
    Pedido: 'Pedido',
    DetallePedido: 'DetallePedido',
    PedidoEvento: 'PedidoEvento'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
     * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  export type Hooks = {
    beforeRequest?: (options: { query: string, path: string[], rootField?: string, typeName?: string, document: any }) => any
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed in to the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type ProductoCountOutputType
   */


  export type ProductoCountOutputType = {
    detallePedidos: number
  }

  export type ProductoCountOutputTypeSelect = {
    detallePedidos?: boolean
  }

  export type ProductoCountOutputTypeGetPayload<
    S extends boolean | null | undefined | ProductoCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? ProductoCountOutputType
    : S extends undefined
    ? never
    : S extends ProductoCountOutputTypeArgs
    ?'include' extends U
    ? ProductoCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof ProductoCountOutputType ? ProductoCountOutputType[P] : never
  } 
    : ProductoCountOutputType
  : ProductoCountOutputType




  // Custom InputTypes

  /**
   * ProductoCountOutputType without action
   */
  export type ProductoCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ProductoCountOutputType
     * 
    **/
    select?: ProductoCountOutputTypeSelect | null
  }



  /**
   * Count Type UsuarioCountOutputType
   */


  export type UsuarioCountOutputType = {
    direciones: number
    pedidos: number
  }

  export type UsuarioCountOutputTypeSelect = {
    direciones?: boolean
    pedidos?: boolean
  }

  export type UsuarioCountOutputTypeGetPayload<
    S extends boolean | null | undefined | UsuarioCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? UsuarioCountOutputType
    : S extends undefined
    ? never
    : S extends UsuarioCountOutputTypeArgs
    ?'include' extends U
    ? UsuarioCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof UsuarioCountOutputType ? UsuarioCountOutputType[P] : never
  } 
    : UsuarioCountOutputType
  : UsuarioCountOutputType




  // Custom InputTypes

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the UsuarioCountOutputType
     * 
    **/
    select?: UsuarioCountOutputTypeSelect | null
  }



  /**
   * Count Type PedidoCountOutputType
   */


  export type PedidoCountOutputType = {
    DetallePedidos: number
    pedidoEventos: number
  }

  export type PedidoCountOutputTypeSelect = {
    DetallePedidos?: boolean
    pedidoEventos?: boolean
  }

  export type PedidoCountOutputTypeGetPayload<
    S extends boolean | null | undefined | PedidoCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? PedidoCountOutputType
    : S extends undefined
    ? never
    : S extends PedidoCountOutputTypeArgs
    ?'include' extends U
    ? PedidoCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof PedidoCountOutputType ? PedidoCountOutputType[P] : never
  } 
    : PedidoCountOutputType
  : PedidoCountOutputType




  // Custom InputTypes

  /**
   * PedidoCountOutputType without action
   */
  export type PedidoCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the PedidoCountOutputType
     * 
    **/
    select?: PedidoCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model Producto
   */


  export type AggregateProducto = {
    _count: ProductoCountAggregateOutputType | null
    _avg: ProductoAvgAggregateOutputType | null
    _sum: ProductoSumAggregateOutputType | null
    _min: ProductoMinAggregateOutputType | null
    _max: ProductoMaxAggregateOutputType | null
  }

  export type ProductoAvgAggregateOutputType = {
    id: number | null
    precio: number | null
    stock: number | null
  }

  export type ProductoSumAggregateOutputType = {
    id: number | null
    precio: number | null
    stock: number | null
  }

  export type ProductoMinAggregateOutputType = {
    id: number | null
    nombre: string | null
    precio: number | null
    unidadMedida: string | null
    stock: number | null
    imagen: string | null
  }

  export type ProductoMaxAggregateOutputType = {
    id: number | null
    nombre: string | null
    precio: number | null
    unidadMedida: string | null
    stock: number | null
    imagen: string | null
  }

  export type ProductoCountAggregateOutputType = {
    id: number
    nombre: number
    precio: number
    unidadMedida: number
    stock: number
    imagen: number
    _all: number
  }


  export type ProductoAvgAggregateInputType = {
    id?: true
    precio?: true
    stock?: true
  }

  export type ProductoSumAggregateInputType = {
    id?: true
    precio?: true
    stock?: true
  }

  export type ProductoMinAggregateInputType = {
    id?: true
    nombre?: true
    precio?: true
    unidadMedida?: true
    stock?: true
    imagen?: true
  }

  export type ProductoMaxAggregateInputType = {
    id?: true
    nombre?: true
    precio?: true
    unidadMedida?: true
    stock?: true
    imagen?: true
  }

  export type ProductoCountAggregateInputType = {
    id?: true
    nombre?: true
    precio?: true
    unidadMedida?: true
    stock?: true
    imagen?: true
    _all?: true
  }

  export type ProductoAggregateArgs = {
    /**
     * Filter which Producto to aggregate.
     * 
    **/
    where?: ProductoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Productos to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ProductoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Productos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Productos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Productos
    **/
    _count?: true | ProductoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductoMaxAggregateInputType
  }

  export type GetProductoAggregateType<T extends ProductoAggregateArgs> = {
        [P in keyof T & keyof AggregateProducto]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProducto[P]>
      : GetScalarType<T[P], AggregateProducto[P]>
  }




  export type ProductoGroupByArgs = {
    where?: ProductoWhereInput
    orderBy?: Enumerable<ProductoOrderByWithAggregationInput>
    by: Array<ProductoScalarFieldEnum>
    having?: ProductoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductoCountAggregateInputType | true
    _avg?: ProductoAvgAggregateInputType
    _sum?: ProductoSumAggregateInputType
    _min?: ProductoMinAggregateInputType
    _max?: ProductoMaxAggregateInputType
  }


  export type ProductoGroupByOutputType = {
    id: number
    nombre: string
    precio: number
    unidadMedida: string
    stock: number
    imagen: string
    _count: ProductoCountAggregateOutputType | null
    _avg: ProductoAvgAggregateOutputType | null
    _sum: ProductoSumAggregateOutputType | null
    _min: ProductoMinAggregateOutputType | null
    _max: ProductoMaxAggregateOutputType | null
  }

  type GetProductoGroupByPayload<T extends ProductoGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ProductoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductoGroupByOutputType[P]>
            : GetScalarType<T[P], ProductoGroupByOutputType[P]>
        }
      >
    >


  export type ProductoSelect = {
    id?: boolean
    nombre?: boolean
    precio?: boolean
    unidadMedida?: boolean
    stock?: boolean
    imagen?: boolean
    detallePedidos?: boolean | DetallePedidoFindManyArgs
    _count?: boolean | ProductoCountOutputTypeArgs
  }

  export type ProductoInclude = {
    detallePedidos?: boolean | DetallePedidoFindManyArgs
    _count?: boolean | ProductoCountOutputTypeArgs
  }

  export type ProductoGetPayload<
    S extends boolean | null | undefined | ProductoArgs,
    U = keyof S
      > = S extends true
        ? Producto
    : S extends undefined
    ? never
    : S extends ProductoArgs | ProductoFindManyArgs
    ?'include' extends U
    ? Producto  & {
    [P in TrueKeys<S['include']>]:
        P extends 'detallePedidos' ? Array < DetallePedidoGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? ProductoCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'detallePedidos' ? Array < DetallePedidoGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? ProductoCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Producto ? Producto[P] : never
  } 
    : Producto
  : Producto


  type ProductoCountArgs = Merge<
    Omit<ProductoFindManyArgs, 'select' | 'include'> & {
      select?: ProductoCountAggregateInputType | true
    }
  >

  export interface ProductoDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Producto that matches the filter.
     * @param {ProductoFindUniqueArgs} args - Arguments to find a Producto
     * @example
     * // Get one Producto
     * const producto = await prisma.producto.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProductoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ProductoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Producto'> extends True ? CheckSelect<T, Prisma__ProductoClient<Producto>, Prisma__ProductoClient<ProductoGetPayload<T>>> : CheckSelect<T, Prisma__ProductoClient<Producto | null, null>, Prisma__ProductoClient<ProductoGetPayload<T> | null, null>>

    /**
     * Find the first Producto that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductoFindFirstArgs} args - Arguments to find a Producto
     * @example
     * // Get one Producto
     * const producto = await prisma.producto.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProductoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ProductoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Producto'> extends True ? CheckSelect<T, Prisma__ProductoClient<Producto>, Prisma__ProductoClient<ProductoGetPayload<T>>> : CheckSelect<T, Prisma__ProductoClient<Producto | null, null>, Prisma__ProductoClient<ProductoGetPayload<T> | null, null>>

    /**
     * Find zero or more Productos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Productos
     * const productos = await prisma.producto.findMany()
     * 
     * // Get first 10 Productos
     * const productos = await prisma.producto.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productoWithIdOnly = await prisma.producto.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProductoFindManyArgs>(
      args?: SelectSubset<T, ProductoFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Producto>>, PrismaPromise<Array<ProductoGetPayload<T>>>>

    /**
     * Create a Producto.
     * @param {ProductoCreateArgs} args - Arguments to create a Producto.
     * @example
     * // Create one Producto
     * const Producto = await prisma.producto.create({
     *   data: {
     *     // ... data to create a Producto
     *   }
     * })
     * 
    **/
    create<T extends ProductoCreateArgs>(
      args: SelectSubset<T, ProductoCreateArgs>
    ): CheckSelect<T, Prisma__ProductoClient<Producto>, Prisma__ProductoClient<ProductoGetPayload<T>>>

    /**
     * Create many Productos.
     *     @param {ProductoCreateManyArgs} args - Arguments to create many Productos.
     *     @example
     *     // Create many Productos
     *     const producto = await prisma.producto.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProductoCreateManyArgs>(
      args?: SelectSubset<T, ProductoCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Producto.
     * @param {ProductoDeleteArgs} args - Arguments to delete one Producto.
     * @example
     * // Delete one Producto
     * const Producto = await prisma.producto.delete({
     *   where: {
     *     // ... filter to delete one Producto
     *   }
     * })
     * 
    **/
    delete<T extends ProductoDeleteArgs>(
      args: SelectSubset<T, ProductoDeleteArgs>
    ): CheckSelect<T, Prisma__ProductoClient<Producto>, Prisma__ProductoClient<ProductoGetPayload<T>>>

    /**
     * Update one Producto.
     * @param {ProductoUpdateArgs} args - Arguments to update one Producto.
     * @example
     * // Update one Producto
     * const producto = await prisma.producto.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProductoUpdateArgs>(
      args: SelectSubset<T, ProductoUpdateArgs>
    ): CheckSelect<T, Prisma__ProductoClient<Producto>, Prisma__ProductoClient<ProductoGetPayload<T>>>

    /**
     * Delete zero or more Productos.
     * @param {ProductoDeleteManyArgs} args - Arguments to filter Productos to delete.
     * @example
     * // Delete a few Productos
     * const { count } = await prisma.producto.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProductoDeleteManyArgs>(
      args?: SelectSubset<T, ProductoDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Productos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Productos
     * const producto = await prisma.producto.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProductoUpdateManyArgs>(
      args: SelectSubset<T, ProductoUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Producto.
     * @param {ProductoUpsertArgs} args - Arguments to update or create a Producto.
     * @example
     * // Update or create a Producto
     * const producto = await prisma.producto.upsert({
     *   create: {
     *     // ... data to create a Producto
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Producto we want to update
     *   }
     * })
    **/
    upsert<T extends ProductoUpsertArgs>(
      args: SelectSubset<T, ProductoUpsertArgs>
    ): CheckSelect<T, Prisma__ProductoClient<Producto>, Prisma__ProductoClient<ProductoGetPayload<T>>>

    /**
     * Find one Producto that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {ProductoFindUniqueOrThrowArgs} args - Arguments to find a Producto
     * @example
     * // Get one Producto
     * const producto = await prisma.producto.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ProductoFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ProductoFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__ProductoClient<Producto>, Prisma__ProductoClient<ProductoGetPayload<T>>>

    /**
     * Find the first Producto that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductoFindFirstOrThrowArgs} args - Arguments to find a Producto
     * @example
     * // Get one Producto
     * const producto = await prisma.producto.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ProductoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ProductoFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__ProductoClient<Producto>, Prisma__ProductoClient<ProductoGetPayload<T>>>

    /**
     * Count the number of Productos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductoCountArgs} args - Arguments to filter Productos to count.
     * @example
     * // Count the number of Productos
     * const count = await prisma.producto.count({
     *   where: {
     *     // ... the filter for the Productos we want to count
     *   }
     * })
    **/
    count<T extends ProductoCountArgs>(
      args?: Subset<T, ProductoCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Producto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductoAggregateArgs>(args: Subset<T, ProductoAggregateArgs>): PrismaPromise<GetProductoAggregateType<T>>

    /**
     * Group by Producto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductoGroupByArgs['orderBy'] }
        : { orderBy?: ProductoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductoGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Producto.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ProductoClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    detallePedidos<T extends DetallePedidoFindManyArgs = {}>(args?: Subset<T, DetallePedidoFindManyArgs>): CheckSelect<T, PrismaPromise<Array<DetallePedido>| Null>, PrismaPromise<Array<DetallePedidoGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Producto base type for findUnique actions
   */
  export type ProductoFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Producto
     * 
    **/
    select?: ProductoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductoInclude | null
    /**
     * Filter, which Producto to fetch.
     * 
    **/
    where: ProductoWhereUniqueInput
  }

  /**
   * Producto: findUnique
   */
  export interface ProductoFindUniqueArgs extends ProductoFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Producto base type for findFirst actions
   */
  export type ProductoFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Producto
     * 
    **/
    select?: ProductoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductoInclude | null
    /**
     * Filter, which Producto to fetch.
     * 
    **/
    where?: ProductoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Productos to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Productos.
     * 
    **/
    cursor?: ProductoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Productos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Productos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Productos.
     * 
    **/
    distinct?: Enumerable<ProductoScalarFieldEnum>
  }

  /**
   * Producto: findFirst
   */
  export interface ProductoFindFirstArgs extends ProductoFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Producto findMany
   */
  export type ProductoFindManyArgs = {
    /**
     * Select specific fields to fetch from the Producto
     * 
    **/
    select?: ProductoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductoInclude | null
    /**
     * Filter, which Productos to fetch.
     * 
    **/
    where?: ProductoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Productos to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Productos.
     * 
    **/
    cursor?: ProductoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Productos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Productos.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ProductoScalarFieldEnum>
  }


  /**
   * Producto create
   */
  export type ProductoCreateArgs = {
    /**
     * Select specific fields to fetch from the Producto
     * 
    **/
    select?: ProductoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductoInclude | null
    /**
     * The data needed to create a Producto.
     * 
    **/
    data: XOR<ProductoCreateInput, ProductoUncheckedCreateInput>
  }


  /**
   * Producto createMany
   */
  export type ProductoCreateManyArgs = {
    /**
     * The data used to create many Productos.
     * 
    **/
    data: Enumerable<ProductoCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Producto update
   */
  export type ProductoUpdateArgs = {
    /**
     * Select specific fields to fetch from the Producto
     * 
    **/
    select?: ProductoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductoInclude | null
    /**
     * The data needed to update a Producto.
     * 
    **/
    data: XOR<ProductoUpdateInput, ProductoUncheckedUpdateInput>
    /**
     * Choose, which Producto to update.
     * 
    **/
    where: ProductoWhereUniqueInput
  }


  /**
   * Producto updateMany
   */
  export type ProductoUpdateManyArgs = {
    /**
     * The data used to update Productos.
     * 
    **/
    data: XOR<ProductoUpdateManyMutationInput, ProductoUncheckedUpdateManyInput>
    /**
     * Filter which Productos to update
     * 
    **/
    where?: ProductoWhereInput
  }


  /**
   * Producto upsert
   */
  export type ProductoUpsertArgs = {
    /**
     * Select specific fields to fetch from the Producto
     * 
    **/
    select?: ProductoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductoInclude | null
    /**
     * The filter to search for the Producto to update in case it exists.
     * 
    **/
    where: ProductoWhereUniqueInput
    /**
     * In case the Producto found by the `where` argument doesn't exist, create a new Producto with this data.
     * 
    **/
    create: XOR<ProductoCreateInput, ProductoUncheckedCreateInput>
    /**
     * In case the Producto was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ProductoUpdateInput, ProductoUncheckedUpdateInput>
  }


  /**
   * Producto delete
   */
  export type ProductoDeleteArgs = {
    /**
     * Select specific fields to fetch from the Producto
     * 
    **/
    select?: ProductoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductoInclude | null
    /**
     * Filter which Producto to delete.
     * 
    **/
    where: ProductoWhereUniqueInput
  }


  /**
   * Producto deleteMany
   */
  export type ProductoDeleteManyArgs = {
    /**
     * Filter which Productos to delete
     * 
    **/
    where?: ProductoWhereInput
  }


  /**
   * Producto: findUniqueOrThrow
   */
  export type ProductoFindUniqueOrThrowArgs = ProductoFindUniqueArgsBase
      

  /**
   * Producto: findFirstOrThrow
   */
  export type ProductoFindFirstOrThrowArgs = ProductoFindFirstArgsBase
      

  /**
   * Producto without action
   */
  export type ProductoArgs = {
    /**
     * Select specific fields to fetch from the Producto
     * 
    **/
    select?: ProductoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductoInclude | null
  }



  /**
   * Model Usuario
   */


  export type AggregateUsuario = {
    _count: UsuarioCountAggregateOutputType | null
    _avg: UsuarioAvgAggregateOutputType | null
    _sum: UsuarioSumAggregateOutputType | null
    _min: UsuarioMinAggregateOutputType | null
    _max: UsuarioMaxAggregateOutputType | null
  }

  export type UsuarioAvgAggregateOutputType = {
    id: number | null
  }

  export type UsuarioSumAggregateOutputType = {
    id: number | null
  }

  export type UsuarioMinAggregateOutputType = {
    id: number | null
    nombre: string | null
    dni: string | null
    correo: string | null
    password: string | null
    telefono: string | null
  }

  export type UsuarioMaxAggregateOutputType = {
    id: number | null
    nombre: string | null
    dni: string | null
    correo: string | null
    password: string | null
    telefono: string | null
  }

  export type UsuarioCountAggregateOutputType = {
    id: number
    nombre: number
    dni: number
    correo: number
    password: number
    telefono: number
    _all: number
  }


  export type UsuarioAvgAggregateInputType = {
    id?: true
  }

  export type UsuarioSumAggregateInputType = {
    id?: true
  }

  export type UsuarioMinAggregateInputType = {
    id?: true
    nombre?: true
    dni?: true
    correo?: true
    password?: true
    telefono?: true
  }

  export type UsuarioMaxAggregateInputType = {
    id?: true
    nombre?: true
    dni?: true
    correo?: true
    password?: true
    telefono?: true
  }

  export type UsuarioCountAggregateInputType = {
    id?: true
    nombre?: true
    dni?: true
    correo?: true
    password?: true
    telefono?: true
    _all?: true
  }

  export type UsuarioAggregateArgs = {
    /**
     * Filter which Usuario to aggregate.
     * 
    **/
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     * 
    **/
    orderBy?: Enumerable<UsuarioOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Usuarios
    **/
    _count?: true | UsuarioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsuarioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsuarioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsuarioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsuarioMaxAggregateInputType
  }

  export type GetUsuarioAggregateType<T extends UsuarioAggregateArgs> = {
        [P in keyof T & keyof AggregateUsuario]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsuario[P]>
      : GetScalarType<T[P], AggregateUsuario[P]>
  }




  export type UsuarioGroupByArgs = {
    where?: UsuarioWhereInput
    orderBy?: Enumerable<UsuarioOrderByWithAggregationInput>
    by: Array<UsuarioScalarFieldEnum>
    having?: UsuarioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsuarioCountAggregateInputType | true
    _avg?: UsuarioAvgAggregateInputType
    _sum?: UsuarioSumAggregateInputType
    _min?: UsuarioMinAggregateInputType
    _max?: UsuarioMaxAggregateInputType
  }


  export type UsuarioGroupByOutputType = {
    id: number
    nombre: string
    dni: string
    correo: string
    password: string
    telefono: string
    _count: UsuarioCountAggregateOutputType | null
    _avg: UsuarioAvgAggregateOutputType | null
    _sum: UsuarioSumAggregateOutputType | null
    _min: UsuarioMinAggregateOutputType | null
    _max: UsuarioMaxAggregateOutputType | null
  }

  type GetUsuarioGroupByPayload<T extends UsuarioGroupByArgs> = PrismaPromise<
    Array<
      PickArray<UsuarioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsuarioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsuarioGroupByOutputType[P]>
            : GetScalarType<T[P], UsuarioGroupByOutputType[P]>
        }
      >
    >


  export type UsuarioSelect = {
    id?: boolean
    nombre?: boolean
    dni?: boolean
    correo?: boolean
    password?: boolean
    telefono?: boolean
    direciones?: boolean | DireccionFindManyArgs
    pedidos?: boolean | PedidoFindManyArgs
    _count?: boolean | UsuarioCountOutputTypeArgs
  }

  export type UsuarioInclude = {
    direciones?: boolean | DireccionFindManyArgs
    pedidos?: boolean | PedidoFindManyArgs
    _count?: boolean | UsuarioCountOutputTypeArgs
  }

  export type UsuarioGetPayload<
    S extends boolean | null | undefined | UsuarioArgs,
    U = keyof S
      > = S extends true
        ? Usuario
    : S extends undefined
    ? never
    : S extends UsuarioArgs | UsuarioFindManyArgs
    ?'include' extends U
    ? Usuario  & {
    [P in TrueKeys<S['include']>]:
        P extends 'direciones' ? Array < DireccionGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'pedidos' ? Array < PedidoGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? UsuarioCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'direciones' ? Array < DireccionGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'pedidos' ? Array < PedidoGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? UsuarioCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Usuario ? Usuario[P] : never
  } 
    : Usuario
  : Usuario


  type UsuarioCountArgs = Merge<
    Omit<UsuarioFindManyArgs, 'select' | 'include'> & {
      select?: UsuarioCountAggregateInputType | true
    }
  >

  export interface UsuarioDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Usuario that matches the filter.
     * @param {UsuarioFindUniqueArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UsuarioFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UsuarioFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Usuario'> extends True ? CheckSelect<T, Prisma__UsuarioClient<Usuario>, Prisma__UsuarioClient<UsuarioGetPayload<T>>> : CheckSelect<T, Prisma__UsuarioClient<Usuario | null, null>, Prisma__UsuarioClient<UsuarioGetPayload<T> | null, null>>

    /**
     * Find the first Usuario that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindFirstArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UsuarioFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UsuarioFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Usuario'> extends True ? CheckSelect<T, Prisma__UsuarioClient<Usuario>, Prisma__UsuarioClient<UsuarioGetPayload<T>>> : CheckSelect<T, Prisma__UsuarioClient<Usuario | null, null>, Prisma__UsuarioClient<UsuarioGetPayload<T> | null, null>>

    /**
     * Find zero or more Usuarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Usuarios
     * const usuarios = await prisma.usuario.findMany()
     * 
     * // Get first 10 Usuarios
     * const usuarios = await prisma.usuario.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usuarioWithIdOnly = await prisma.usuario.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UsuarioFindManyArgs>(
      args?: SelectSubset<T, UsuarioFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Usuario>>, PrismaPromise<Array<UsuarioGetPayload<T>>>>

    /**
     * Create a Usuario.
     * @param {UsuarioCreateArgs} args - Arguments to create a Usuario.
     * @example
     * // Create one Usuario
     * const Usuario = await prisma.usuario.create({
     *   data: {
     *     // ... data to create a Usuario
     *   }
     * })
     * 
    **/
    create<T extends UsuarioCreateArgs>(
      args: SelectSubset<T, UsuarioCreateArgs>
    ): CheckSelect<T, Prisma__UsuarioClient<Usuario>, Prisma__UsuarioClient<UsuarioGetPayload<T>>>

    /**
     * Create many Usuarios.
     *     @param {UsuarioCreateManyArgs} args - Arguments to create many Usuarios.
     *     @example
     *     // Create many Usuarios
     *     const usuario = await prisma.usuario.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UsuarioCreateManyArgs>(
      args?: SelectSubset<T, UsuarioCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Usuario.
     * @param {UsuarioDeleteArgs} args - Arguments to delete one Usuario.
     * @example
     * // Delete one Usuario
     * const Usuario = await prisma.usuario.delete({
     *   where: {
     *     // ... filter to delete one Usuario
     *   }
     * })
     * 
    **/
    delete<T extends UsuarioDeleteArgs>(
      args: SelectSubset<T, UsuarioDeleteArgs>
    ): CheckSelect<T, Prisma__UsuarioClient<Usuario>, Prisma__UsuarioClient<UsuarioGetPayload<T>>>

    /**
     * Update one Usuario.
     * @param {UsuarioUpdateArgs} args - Arguments to update one Usuario.
     * @example
     * // Update one Usuario
     * const usuario = await prisma.usuario.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UsuarioUpdateArgs>(
      args: SelectSubset<T, UsuarioUpdateArgs>
    ): CheckSelect<T, Prisma__UsuarioClient<Usuario>, Prisma__UsuarioClient<UsuarioGetPayload<T>>>

    /**
     * Delete zero or more Usuarios.
     * @param {UsuarioDeleteManyArgs} args - Arguments to filter Usuarios to delete.
     * @example
     * // Delete a few Usuarios
     * const { count } = await prisma.usuario.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UsuarioDeleteManyArgs>(
      args?: SelectSubset<T, UsuarioDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Usuarios
     * const usuario = await prisma.usuario.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UsuarioUpdateManyArgs>(
      args: SelectSubset<T, UsuarioUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Usuario.
     * @param {UsuarioUpsertArgs} args - Arguments to update or create a Usuario.
     * @example
     * // Update or create a Usuario
     * const usuario = await prisma.usuario.upsert({
     *   create: {
     *     // ... data to create a Usuario
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Usuario we want to update
     *   }
     * })
    **/
    upsert<T extends UsuarioUpsertArgs>(
      args: SelectSubset<T, UsuarioUpsertArgs>
    ): CheckSelect<T, Prisma__UsuarioClient<Usuario>, Prisma__UsuarioClient<UsuarioGetPayload<T>>>

    /**
     * Find one Usuario that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {UsuarioFindUniqueOrThrowArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UsuarioFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, UsuarioFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__UsuarioClient<Usuario>, Prisma__UsuarioClient<UsuarioGetPayload<T>>>

    /**
     * Find the first Usuario that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindFirstOrThrowArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UsuarioFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UsuarioFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__UsuarioClient<Usuario>, Prisma__UsuarioClient<UsuarioGetPayload<T>>>

    /**
     * Count the number of Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioCountArgs} args - Arguments to filter Usuarios to count.
     * @example
     * // Count the number of Usuarios
     * const count = await prisma.usuario.count({
     *   where: {
     *     // ... the filter for the Usuarios we want to count
     *   }
     * })
    **/
    count<T extends UsuarioCountArgs>(
      args?: Subset<T, UsuarioCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsuarioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsuarioAggregateArgs>(args: Subset<T, UsuarioAggregateArgs>): PrismaPromise<GetUsuarioAggregateType<T>>

    /**
     * Group by Usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsuarioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsuarioGroupByArgs['orderBy'] }
        : { orderBy?: UsuarioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsuarioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsuarioGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Usuario.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UsuarioClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    direciones<T extends DireccionFindManyArgs = {}>(args?: Subset<T, DireccionFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Direccion>| Null>, PrismaPromise<Array<DireccionGetPayload<T>>| Null>>;

    pedidos<T extends PedidoFindManyArgs = {}>(args?: Subset<T, PedidoFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Pedido>| Null>, PrismaPromise<Array<PedidoGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Usuario base type for findUnique actions
   */
  export type UsuarioFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Usuario
     * 
    **/
    select?: UsuarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UsuarioInclude | null
    /**
     * Filter, which Usuario to fetch.
     * 
    **/
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario: findUnique
   */
  export interface UsuarioFindUniqueArgs extends UsuarioFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Usuario base type for findFirst actions
   */
  export type UsuarioFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Usuario
     * 
    **/
    select?: UsuarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UsuarioInclude | null
    /**
     * Filter, which Usuario to fetch.
     * 
    **/
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     * 
    **/
    orderBy?: Enumerable<UsuarioOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Usuarios.
     * 
    **/
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Usuarios.
     * 
    **/
    distinct?: Enumerable<UsuarioScalarFieldEnum>
  }

  /**
   * Usuario: findFirst
   */
  export interface UsuarioFindFirstArgs extends UsuarioFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Usuario findMany
   */
  export type UsuarioFindManyArgs = {
    /**
     * Select specific fields to fetch from the Usuario
     * 
    **/
    select?: UsuarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UsuarioInclude | null
    /**
     * Filter, which Usuarios to fetch.
     * 
    **/
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     * 
    **/
    orderBy?: Enumerable<UsuarioOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Usuarios.
     * 
    **/
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     * 
    **/
    skip?: number
    distinct?: Enumerable<UsuarioScalarFieldEnum>
  }


  /**
   * Usuario create
   */
  export type UsuarioCreateArgs = {
    /**
     * Select specific fields to fetch from the Usuario
     * 
    **/
    select?: UsuarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UsuarioInclude | null
    /**
     * The data needed to create a Usuario.
     * 
    **/
    data: XOR<UsuarioCreateInput, UsuarioUncheckedCreateInput>
  }


  /**
   * Usuario createMany
   */
  export type UsuarioCreateManyArgs = {
    /**
     * The data used to create many Usuarios.
     * 
    **/
    data: Enumerable<UsuarioCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Usuario update
   */
  export type UsuarioUpdateArgs = {
    /**
     * Select specific fields to fetch from the Usuario
     * 
    **/
    select?: UsuarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UsuarioInclude | null
    /**
     * The data needed to update a Usuario.
     * 
    **/
    data: XOR<UsuarioUpdateInput, UsuarioUncheckedUpdateInput>
    /**
     * Choose, which Usuario to update.
     * 
    **/
    where: UsuarioWhereUniqueInput
  }


  /**
   * Usuario updateMany
   */
  export type UsuarioUpdateManyArgs = {
    /**
     * The data used to update Usuarios.
     * 
    **/
    data: XOR<UsuarioUpdateManyMutationInput, UsuarioUncheckedUpdateManyInput>
    /**
     * Filter which Usuarios to update
     * 
    **/
    where?: UsuarioWhereInput
  }


  /**
   * Usuario upsert
   */
  export type UsuarioUpsertArgs = {
    /**
     * Select specific fields to fetch from the Usuario
     * 
    **/
    select?: UsuarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UsuarioInclude | null
    /**
     * The filter to search for the Usuario to update in case it exists.
     * 
    **/
    where: UsuarioWhereUniqueInput
    /**
     * In case the Usuario found by the `where` argument doesn't exist, create a new Usuario with this data.
     * 
    **/
    create: XOR<UsuarioCreateInput, UsuarioUncheckedCreateInput>
    /**
     * In case the Usuario was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<UsuarioUpdateInput, UsuarioUncheckedUpdateInput>
  }


  /**
   * Usuario delete
   */
  export type UsuarioDeleteArgs = {
    /**
     * Select specific fields to fetch from the Usuario
     * 
    **/
    select?: UsuarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UsuarioInclude | null
    /**
     * Filter which Usuario to delete.
     * 
    **/
    where: UsuarioWhereUniqueInput
  }


  /**
   * Usuario deleteMany
   */
  export type UsuarioDeleteManyArgs = {
    /**
     * Filter which Usuarios to delete
     * 
    **/
    where?: UsuarioWhereInput
  }


  /**
   * Usuario: findUniqueOrThrow
   */
  export type UsuarioFindUniqueOrThrowArgs = UsuarioFindUniqueArgsBase
      

  /**
   * Usuario: findFirstOrThrow
   */
  export type UsuarioFindFirstOrThrowArgs = UsuarioFindFirstArgsBase
      

  /**
   * Usuario without action
   */
  export type UsuarioArgs = {
    /**
     * Select specific fields to fetch from the Usuario
     * 
    **/
    select?: UsuarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UsuarioInclude | null
  }



  /**
   * Model Direccion
   */


  export type AggregateDireccion = {
    _count: DireccionCountAggregateOutputType | null
    _avg: DireccionAvgAggregateOutputType | null
    _sum: DireccionSumAggregateOutputType | null
    _min: DireccionMinAggregateOutputType | null
    _max: DireccionMaxAggregateOutputType | null
  }

  export type DireccionAvgAggregateOutputType = {
    id: number | null
    usuarioId: number | null
  }

  export type DireccionSumAggregateOutputType = {
    id: number | null
    usuarioId: number | null
  }

  export type DireccionMinAggregateOutputType = {
    id: number | null
    calle: string | null
    numero: string | null
    dpt: string | null
    ciudad: string | null
    provincia: string | null
    referencia: string | null
    usuarioId: number | null
  }

  export type DireccionMaxAggregateOutputType = {
    id: number | null
    calle: string | null
    numero: string | null
    dpt: string | null
    ciudad: string | null
    provincia: string | null
    referencia: string | null
    usuarioId: number | null
  }

  export type DireccionCountAggregateOutputType = {
    id: number
    calle: number
    numero: number
    dpt: number
    ciudad: number
    provincia: number
    referencia: number
    usuarioId: number
    _all: number
  }


  export type DireccionAvgAggregateInputType = {
    id?: true
    usuarioId?: true
  }

  export type DireccionSumAggregateInputType = {
    id?: true
    usuarioId?: true
  }

  export type DireccionMinAggregateInputType = {
    id?: true
    calle?: true
    numero?: true
    dpt?: true
    ciudad?: true
    provincia?: true
    referencia?: true
    usuarioId?: true
  }

  export type DireccionMaxAggregateInputType = {
    id?: true
    calle?: true
    numero?: true
    dpt?: true
    ciudad?: true
    provincia?: true
    referencia?: true
    usuarioId?: true
  }

  export type DireccionCountAggregateInputType = {
    id?: true
    calle?: true
    numero?: true
    dpt?: true
    ciudad?: true
    provincia?: true
    referencia?: true
    usuarioId?: true
    _all?: true
  }

  export type DireccionAggregateArgs = {
    /**
     * Filter which Direccion to aggregate.
     * 
    **/
    where?: DireccionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Direccions to fetch.
     * 
    **/
    orderBy?: Enumerable<DireccionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: DireccionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Direccions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Direccions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Direccions
    **/
    _count?: true | DireccionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DireccionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DireccionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DireccionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DireccionMaxAggregateInputType
  }

  export type GetDireccionAggregateType<T extends DireccionAggregateArgs> = {
        [P in keyof T & keyof AggregateDireccion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDireccion[P]>
      : GetScalarType<T[P], AggregateDireccion[P]>
  }




  export type DireccionGroupByArgs = {
    where?: DireccionWhereInput
    orderBy?: Enumerable<DireccionOrderByWithAggregationInput>
    by: Array<DireccionScalarFieldEnum>
    having?: DireccionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DireccionCountAggregateInputType | true
    _avg?: DireccionAvgAggregateInputType
    _sum?: DireccionSumAggregateInputType
    _min?: DireccionMinAggregateInputType
    _max?: DireccionMaxAggregateInputType
  }


  export type DireccionGroupByOutputType = {
    id: number
    calle: string
    numero: string
    dpt: string
    ciudad: string
    provincia: string
    referencia: string | null
    usuarioId: number
    _count: DireccionCountAggregateOutputType | null
    _avg: DireccionAvgAggregateOutputType | null
    _sum: DireccionSumAggregateOutputType | null
    _min: DireccionMinAggregateOutputType | null
    _max: DireccionMaxAggregateOutputType | null
  }

  type GetDireccionGroupByPayload<T extends DireccionGroupByArgs> = PrismaPromise<
    Array<
      PickArray<DireccionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DireccionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DireccionGroupByOutputType[P]>
            : GetScalarType<T[P], DireccionGroupByOutputType[P]>
        }
      >
    >


  export type DireccionSelect = {
    id?: boolean
    calle?: boolean
    numero?: boolean
    dpt?: boolean
    ciudad?: boolean
    provincia?: boolean
    referencia?: boolean
    usuarioId?: boolean
    usuario?: boolean | UsuarioArgs
  }

  export type DireccionInclude = {
    usuario?: boolean | UsuarioArgs
  }

  export type DireccionGetPayload<
    S extends boolean | null | undefined | DireccionArgs,
    U = keyof S
      > = S extends true
        ? Direccion
    : S extends undefined
    ? never
    : S extends DireccionArgs | DireccionFindManyArgs
    ?'include' extends U
    ? Direccion  & {
    [P in TrueKeys<S['include']>]:
        P extends 'usuario' ? UsuarioGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'usuario' ? UsuarioGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Direccion ? Direccion[P] : never
  } 
    : Direccion
  : Direccion


  type DireccionCountArgs = Merge<
    Omit<DireccionFindManyArgs, 'select' | 'include'> & {
      select?: DireccionCountAggregateInputType | true
    }
  >

  export interface DireccionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Direccion that matches the filter.
     * @param {DireccionFindUniqueArgs} args - Arguments to find a Direccion
     * @example
     * // Get one Direccion
     * const direccion = await prisma.direccion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DireccionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DireccionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Direccion'> extends True ? CheckSelect<T, Prisma__DireccionClient<Direccion>, Prisma__DireccionClient<DireccionGetPayload<T>>> : CheckSelect<T, Prisma__DireccionClient<Direccion | null, null>, Prisma__DireccionClient<DireccionGetPayload<T> | null, null>>

    /**
     * Find the first Direccion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DireccionFindFirstArgs} args - Arguments to find a Direccion
     * @example
     * // Get one Direccion
     * const direccion = await prisma.direccion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DireccionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DireccionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Direccion'> extends True ? CheckSelect<T, Prisma__DireccionClient<Direccion>, Prisma__DireccionClient<DireccionGetPayload<T>>> : CheckSelect<T, Prisma__DireccionClient<Direccion | null, null>, Prisma__DireccionClient<DireccionGetPayload<T> | null, null>>

    /**
     * Find zero or more Direccions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DireccionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Direccions
     * const direccions = await prisma.direccion.findMany()
     * 
     * // Get first 10 Direccions
     * const direccions = await prisma.direccion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const direccionWithIdOnly = await prisma.direccion.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DireccionFindManyArgs>(
      args?: SelectSubset<T, DireccionFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Direccion>>, PrismaPromise<Array<DireccionGetPayload<T>>>>

    /**
     * Create a Direccion.
     * @param {DireccionCreateArgs} args - Arguments to create a Direccion.
     * @example
     * // Create one Direccion
     * const Direccion = await prisma.direccion.create({
     *   data: {
     *     // ... data to create a Direccion
     *   }
     * })
     * 
    **/
    create<T extends DireccionCreateArgs>(
      args: SelectSubset<T, DireccionCreateArgs>
    ): CheckSelect<T, Prisma__DireccionClient<Direccion>, Prisma__DireccionClient<DireccionGetPayload<T>>>

    /**
     * Create many Direccions.
     *     @param {DireccionCreateManyArgs} args - Arguments to create many Direccions.
     *     @example
     *     // Create many Direccions
     *     const direccion = await prisma.direccion.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DireccionCreateManyArgs>(
      args?: SelectSubset<T, DireccionCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Direccion.
     * @param {DireccionDeleteArgs} args - Arguments to delete one Direccion.
     * @example
     * // Delete one Direccion
     * const Direccion = await prisma.direccion.delete({
     *   where: {
     *     // ... filter to delete one Direccion
     *   }
     * })
     * 
    **/
    delete<T extends DireccionDeleteArgs>(
      args: SelectSubset<T, DireccionDeleteArgs>
    ): CheckSelect<T, Prisma__DireccionClient<Direccion>, Prisma__DireccionClient<DireccionGetPayload<T>>>

    /**
     * Update one Direccion.
     * @param {DireccionUpdateArgs} args - Arguments to update one Direccion.
     * @example
     * // Update one Direccion
     * const direccion = await prisma.direccion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DireccionUpdateArgs>(
      args: SelectSubset<T, DireccionUpdateArgs>
    ): CheckSelect<T, Prisma__DireccionClient<Direccion>, Prisma__DireccionClient<DireccionGetPayload<T>>>

    /**
     * Delete zero or more Direccions.
     * @param {DireccionDeleteManyArgs} args - Arguments to filter Direccions to delete.
     * @example
     * // Delete a few Direccions
     * const { count } = await prisma.direccion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DireccionDeleteManyArgs>(
      args?: SelectSubset<T, DireccionDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Direccions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DireccionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Direccions
     * const direccion = await prisma.direccion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DireccionUpdateManyArgs>(
      args: SelectSubset<T, DireccionUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Direccion.
     * @param {DireccionUpsertArgs} args - Arguments to update or create a Direccion.
     * @example
     * // Update or create a Direccion
     * const direccion = await prisma.direccion.upsert({
     *   create: {
     *     // ... data to create a Direccion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Direccion we want to update
     *   }
     * })
    **/
    upsert<T extends DireccionUpsertArgs>(
      args: SelectSubset<T, DireccionUpsertArgs>
    ): CheckSelect<T, Prisma__DireccionClient<Direccion>, Prisma__DireccionClient<DireccionGetPayload<T>>>

    /**
     * Find one Direccion that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {DireccionFindUniqueOrThrowArgs} args - Arguments to find a Direccion
     * @example
     * // Get one Direccion
     * const direccion = await prisma.direccion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DireccionFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, DireccionFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__DireccionClient<Direccion>, Prisma__DireccionClient<DireccionGetPayload<T>>>

    /**
     * Find the first Direccion that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DireccionFindFirstOrThrowArgs} args - Arguments to find a Direccion
     * @example
     * // Get one Direccion
     * const direccion = await prisma.direccion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DireccionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, DireccionFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__DireccionClient<Direccion>, Prisma__DireccionClient<DireccionGetPayload<T>>>

    /**
     * Count the number of Direccions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DireccionCountArgs} args - Arguments to filter Direccions to count.
     * @example
     * // Count the number of Direccions
     * const count = await prisma.direccion.count({
     *   where: {
     *     // ... the filter for the Direccions we want to count
     *   }
     * })
    **/
    count<T extends DireccionCountArgs>(
      args?: Subset<T, DireccionCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DireccionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Direccion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DireccionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DireccionAggregateArgs>(args: Subset<T, DireccionAggregateArgs>): PrismaPromise<GetDireccionAggregateType<T>>

    /**
     * Group by Direccion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DireccionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DireccionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DireccionGroupByArgs['orderBy'] }
        : { orderBy?: DireccionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DireccionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDireccionGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Direccion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DireccionClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    usuario<T extends UsuarioArgs = {}>(args?: Subset<T, UsuarioArgs>): CheckSelect<T, Prisma__UsuarioClient<Usuario | Null>, Prisma__UsuarioClient<UsuarioGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Direccion base type for findUnique actions
   */
  export type DireccionFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Direccion
     * 
    **/
    select?: DireccionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DireccionInclude | null
    /**
     * Filter, which Direccion to fetch.
     * 
    **/
    where: DireccionWhereUniqueInput
  }

  /**
   * Direccion: findUnique
   */
  export interface DireccionFindUniqueArgs extends DireccionFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Direccion base type for findFirst actions
   */
  export type DireccionFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Direccion
     * 
    **/
    select?: DireccionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DireccionInclude | null
    /**
     * Filter, which Direccion to fetch.
     * 
    **/
    where?: DireccionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Direccions to fetch.
     * 
    **/
    orderBy?: Enumerable<DireccionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Direccions.
     * 
    **/
    cursor?: DireccionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Direccions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Direccions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Direccions.
     * 
    **/
    distinct?: Enumerable<DireccionScalarFieldEnum>
  }

  /**
   * Direccion: findFirst
   */
  export interface DireccionFindFirstArgs extends DireccionFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Direccion findMany
   */
  export type DireccionFindManyArgs = {
    /**
     * Select specific fields to fetch from the Direccion
     * 
    **/
    select?: DireccionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DireccionInclude | null
    /**
     * Filter, which Direccions to fetch.
     * 
    **/
    where?: DireccionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Direccions to fetch.
     * 
    **/
    orderBy?: Enumerable<DireccionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Direccions.
     * 
    **/
    cursor?: DireccionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Direccions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Direccions.
     * 
    **/
    skip?: number
    distinct?: Enumerable<DireccionScalarFieldEnum>
  }


  /**
   * Direccion create
   */
  export type DireccionCreateArgs = {
    /**
     * Select specific fields to fetch from the Direccion
     * 
    **/
    select?: DireccionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DireccionInclude | null
    /**
     * The data needed to create a Direccion.
     * 
    **/
    data: XOR<DireccionCreateInput, DireccionUncheckedCreateInput>
  }


  /**
   * Direccion createMany
   */
  export type DireccionCreateManyArgs = {
    /**
     * The data used to create many Direccions.
     * 
    **/
    data: Enumerable<DireccionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Direccion update
   */
  export type DireccionUpdateArgs = {
    /**
     * Select specific fields to fetch from the Direccion
     * 
    **/
    select?: DireccionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DireccionInclude | null
    /**
     * The data needed to update a Direccion.
     * 
    **/
    data: XOR<DireccionUpdateInput, DireccionUncheckedUpdateInput>
    /**
     * Choose, which Direccion to update.
     * 
    **/
    where: DireccionWhereUniqueInput
  }


  /**
   * Direccion updateMany
   */
  export type DireccionUpdateManyArgs = {
    /**
     * The data used to update Direccions.
     * 
    **/
    data: XOR<DireccionUpdateManyMutationInput, DireccionUncheckedUpdateManyInput>
    /**
     * Filter which Direccions to update
     * 
    **/
    where?: DireccionWhereInput
  }


  /**
   * Direccion upsert
   */
  export type DireccionUpsertArgs = {
    /**
     * Select specific fields to fetch from the Direccion
     * 
    **/
    select?: DireccionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DireccionInclude | null
    /**
     * The filter to search for the Direccion to update in case it exists.
     * 
    **/
    where: DireccionWhereUniqueInput
    /**
     * In case the Direccion found by the `where` argument doesn't exist, create a new Direccion with this data.
     * 
    **/
    create: XOR<DireccionCreateInput, DireccionUncheckedCreateInput>
    /**
     * In case the Direccion was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<DireccionUpdateInput, DireccionUncheckedUpdateInput>
  }


  /**
   * Direccion delete
   */
  export type DireccionDeleteArgs = {
    /**
     * Select specific fields to fetch from the Direccion
     * 
    **/
    select?: DireccionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DireccionInclude | null
    /**
     * Filter which Direccion to delete.
     * 
    **/
    where: DireccionWhereUniqueInput
  }


  /**
   * Direccion deleteMany
   */
  export type DireccionDeleteManyArgs = {
    /**
     * Filter which Direccions to delete
     * 
    **/
    where?: DireccionWhereInput
  }


  /**
   * Direccion: findUniqueOrThrow
   */
  export type DireccionFindUniqueOrThrowArgs = DireccionFindUniqueArgsBase
      

  /**
   * Direccion: findFirstOrThrow
   */
  export type DireccionFindFirstOrThrowArgs = DireccionFindFirstArgsBase
      

  /**
   * Direccion without action
   */
  export type DireccionArgs = {
    /**
     * Select specific fields to fetch from the Direccion
     * 
    **/
    select?: DireccionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DireccionInclude | null
  }



  /**
   * Model Pedido
   */


  export type AggregatePedido = {
    _count: PedidoCountAggregateOutputType | null
    _avg: PedidoAvgAggregateOutputType | null
    _sum: PedidoSumAggregateOutputType | null
    _min: PedidoMinAggregateOutputType | null
    _max: PedidoMaxAggregateOutputType | null
  }

  export type PedidoAvgAggregateOutputType = {
    id: number | null
    montoTotal: number | null
    direccionId: number | null
    usuarioId: number | null
  }

  export type PedidoSumAggregateOutputType = {
    id: number | null
    montoTotal: number | null
    direccionId: number | null
    usuarioId: number | null
  }

  export type PedidoMinAggregateOutputType = {
    id: number | null
    montoTotal: number | null
    numeroSeguimiento: string | null
    estado: PedidoEstado | null
    fecha: Date | null
    direccionId: number | null
    usuarioId: number | null
  }

  export type PedidoMaxAggregateOutputType = {
    id: number | null
    montoTotal: number | null
    numeroSeguimiento: string | null
    estado: PedidoEstado | null
    fecha: Date | null
    direccionId: number | null
    usuarioId: number | null
  }

  export type PedidoCountAggregateOutputType = {
    id: number
    montoTotal: number
    numeroSeguimiento: number
    estado: number
    fecha: number
    direccionId: number
    usuarioId: number
    _all: number
  }


  export type PedidoAvgAggregateInputType = {
    id?: true
    montoTotal?: true
    direccionId?: true
    usuarioId?: true
  }

  export type PedidoSumAggregateInputType = {
    id?: true
    montoTotal?: true
    direccionId?: true
    usuarioId?: true
  }

  export type PedidoMinAggregateInputType = {
    id?: true
    montoTotal?: true
    numeroSeguimiento?: true
    estado?: true
    fecha?: true
    direccionId?: true
    usuarioId?: true
  }

  export type PedidoMaxAggregateInputType = {
    id?: true
    montoTotal?: true
    numeroSeguimiento?: true
    estado?: true
    fecha?: true
    direccionId?: true
    usuarioId?: true
  }

  export type PedidoCountAggregateInputType = {
    id?: true
    montoTotal?: true
    numeroSeguimiento?: true
    estado?: true
    fecha?: true
    direccionId?: true
    usuarioId?: true
    _all?: true
  }

  export type PedidoAggregateArgs = {
    /**
     * Filter which Pedido to aggregate.
     * 
    **/
    where?: PedidoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pedidos to fetch.
     * 
    **/
    orderBy?: Enumerable<PedidoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: PedidoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pedidos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pedidos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Pedidos
    **/
    _count?: true | PedidoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PedidoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PedidoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PedidoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PedidoMaxAggregateInputType
  }

  export type GetPedidoAggregateType<T extends PedidoAggregateArgs> = {
        [P in keyof T & keyof AggregatePedido]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePedido[P]>
      : GetScalarType<T[P], AggregatePedido[P]>
  }




  export type PedidoGroupByArgs = {
    where?: PedidoWhereInput
    orderBy?: Enumerable<PedidoOrderByWithAggregationInput>
    by: Array<PedidoScalarFieldEnum>
    having?: PedidoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PedidoCountAggregateInputType | true
    _avg?: PedidoAvgAggregateInputType
    _sum?: PedidoSumAggregateInputType
    _min?: PedidoMinAggregateInputType
    _max?: PedidoMaxAggregateInputType
  }


  export type PedidoGroupByOutputType = {
    id: number
    montoTotal: number
    numeroSeguimiento: string | null
    estado: PedidoEstado
    fecha: Date
    direccionId: number
    usuarioId: number
    _count: PedidoCountAggregateOutputType | null
    _avg: PedidoAvgAggregateOutputType | null
    _sum: PedidoSumAggregateOutputType | null
    _min: PedidoMinAggregateOutputType | null
    _max: PedidoMaxAggregateOutputType | null
  }

  type GetPedidoGroupByPayload<T extends PedidoGroupByArgs> = PrismaPromise<
    Array<
      PickArray<PedidoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PedidoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PedidoGroupByOutputType[P]>
            : GetScalarType<T[P], PedidoGroupByOutputType[P]>
        }
      >
    >


  export type PedidoSelect = {
    id?: boolean
    montoTotal?: boolean
    numeroSeguimiento?: boolean
    estado?: boolean
    fecha?: boolean
    direccionId?: boolean
    usuarioId?: boolean
    DetallePedidos?: boolean | DetallePedidoFindManyArgs
    pedidoEventos?: boolean | PedidoEventoFindManyArgs
    usuario?: boolean | UsuarioArgs
    _count?: boolean | PedidoCountOutputTypeArgs
  }

  export type PedidoInclude = {
    DetallePedidos?: boolean | DetallePedidoFindManyArgs
    pedidoEventos?: boolean | PedidoEventoFindManyArgs
    usuario?: boolean | UsuarioArgs
    _count?: boolean | PedidoCountOutputTypeArgs
  }

  export type PedidoGetPayload<
    S extends boolean | null | undefined | PedidoArgs,
    U = keyof S
      > = S extends true
        ? Pedido
    : S extends undefined
    ? never
    : S extends PedidoArgs | PedidoFindManyArgs
    ?'include' extends U
    ? Pedido  & {
    [P in TrueKeys<S['include']>]:
        P extends 'DetallePedidos' ? Array < DetallePedidoGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'pedidoEventos' ? Array < PedidoEventoGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'usuario' ? UsuarioGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends '_count' ? PedidoCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'DetallePedidos' ? Array < DetallePedidoGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'pedidoEventos' ? Array < PedidoEventoGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'usuario' ? UsuarioGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends '_count' ? PedidoCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof Pedido ? Pedido[P] : never
  } 
    : Pedido
  : Pedido


  type PedidoCountArgs = Merge<
    Omit<PedidoFindManyArgs, 'select' | 'include'> & {
      select?: PedidoCountAggregateInputType | true
    }
  >

  export interface PedidoDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Pedido that matches the filter.
     * @param {PedidoFindUniqueArgs} args - Arguments to find a Pedido
     * @example
     * // Get one Pedido
     * const pedido = await prisma.pedido.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PedidoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PedidoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Pedido'> extends True ? CheckSelect<T, Prisma__PedidoClient<Pedido>, Prisma__PedidoClient<PedidoGetPayload<T>>> : CheckSelect<T, Prisma__PedidoClient<Pedido | null, null>, Prisma__PedidoClient<PedidoGetPayload<T> | null, null>>

    /**
     * Find the first Pedido that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoFindFirstArgs} args - Arguments to find a Pedido
     * @example
     * // Get one Pedido
     * const pedido = await prisma.pedido.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PedidoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PedidoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Pedido'> extends True ? CheckSelect<T, Prisma__PedidoClient<Pedido>, Prisma__PedidoClient<PedidoGetPayload<T>>> : CheckSelect<T, Prisma__PedidoClient<Pedido | null, null>, Prisma__PedidoClient<PedidoGetPayload<T> | null, null>>

    /**
     * Find zero or more Pedidos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pedidos
     * const pedidos = await prisma.pedido.findMany()
     * 
     * // Get first 10 Pedidos
     * const pedidos = await prisma.pedido.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pedidoWithIdOnly = await prisma.pedido.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PedidoFindManyArgs>(
      args?: SelectSubset<T, PedidoFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Pedido>>, PrismaPromise<Array<PedidoGetPayload<T>>>>

    /**
     * Create a Pedido.
     * @param {PedidoCreateArgs} args - Arguments to create a Pedido.
     * @example
     * // Create one Pedido
     * const Pedido = await prisma.pedido.create({
     *   data: {
     *     // ... data to create a Pedido
     *   }
     * })
     * 
    **/
    create<T extends PedidoCreateArgs>(
      args: SelectSubset<T, PedidoCreateArgs>
    ): CheckSelect<T, Prisma__PedidoClient<Pedido>, Prisma__PedidoClient<PedidoGetPayload<T>>>

    /**
     * Create many Pedidos.
     *     @param {PedidoCreateManyArgs} args - Arguments to create many Pedidos.
     *     @example
     *     // Create many Pedidos
     *     const pedido = await prisma.pedido.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PedidoCreateManyArgs>(
      args?: SelectSubset<T, PedidoCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Pedido.
     * @param {PedidoDeleteArgs} args - Arguments to delete one Pedido.
     * @example
     * // Delete one Pedido
     * const Pedido = await prisma.pedido.delete({
     *   where: {
     *     // ... filter to delete one Pedido
     *   }
     * })
     * 
    **/
    delete<T extends PedidoDeleteArgs>(
      args: SelectSubset<T, PedidoDeleteArgs>
    ): CheckSelect<T, Prisma__PedidoClient<Pedido>, Prisma__PedidoClient<PedidoGetPayload<T>>>

    /**
     * Update one Pedido.
     * @param {PedidoUpdateArgs} args - Arguments to update one Pedido.
     * @example
     * // Update one Pedido
     * const pedido = await prisma.pedido.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PedidoUpdateArgs>(
      args: SelectSubset<T, PedidoUpdateArgs>
    ): CheckSelect<T, Prisma__PedidoClient<Pedido>, Prisma__PedidoClient<PedidoGetPayload<T>>>

    /**
     * Delete zero or more Pedidos.
     * @param {PedidoDeleteManyArgs} args - Arguments to filter Pedidos to delete.
     * @example
     * // Delete a few Pedidos
     * const { count } = await prisma.pedido.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PedidoDeleteManyArgs>(
      args?: SelectSubset<T, PedidoDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pedidos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pedidos
     * const pedido = await prisma.pedido.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PedidoUpdateManyArgs>(
      args: SelectSubset<T, PedidoUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Pedido.
     * @param {PedidoUpsertArgs} args - Arguments to update or create a Pedido.
     * @example
     * // Update or create a Pedido
     * const pedido = await prisma.pedido.upsert({
     *   create: {
     *     // ... data to create a Pedido
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pedido we want to update
     *   }
     * })
    **/
    upsert<T extends PedidoUpsertArgs>(
      args: SelectSubset<T, PedidoUpsertArgs>
    ): CheckSelect<T, Prisma__PedidoClient<Pedido>, Prisma__PedidoClient<PedidoGetPayload<T>>>

    /**
     * Find one Pedido that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {PedidoFindUniqueOrThrowArgs} args - Arguments to find a Pedido
     * @example
     * // Get one Pedido
     * const pedido = await prisma.pedido.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PedidoFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, PedidoFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__PedidoClient<Pedido>, Prisma__PedidoClient<PedidoGetPayload<T>>>

    /**
     * Find the first Pedido that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoFindFirstOrThrowArgs} args - Arguments to find a Pedido
     * @example
     * // Get one Pedido
     * const pedido = await prisma.pedido.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PedidoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PedidoFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__PedidoClient<Pedido>, Prisma__PedidoClient<PedidoGetPayload<T>>>

    /**
     * Count the number of Pedidos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoCountArgs} args - Arguments to filter Pedidos to count.
     * @example
     * // Count the number of Pedidos
     * const count = await prisma.pedido.count({
     *   where: {
     *     // ... the filter for the Pedidos we want to count
     *   }
     * })
    **/
    count<T extends PedidoCountArgs>(
      args?: Subset<T, PedidoCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PedidoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pedido.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PedidoAggregateArgs>(args: Subset<T, PedidoAggregateArgs>): PrismaPromise<GetPedidoAggregateType<T>>

    /**
     * Group by Pedido.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PedidoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PedidoGroupByArgs['orderBy'] }
        : { orderBy?: PedidoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PedidoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPedidoGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Pedido.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PedidoClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    DetallePedidos<T extends DetallePedidoFindManyArgs = {}>(args?: Subset<T, DetallePedidoFindManyArgs>): CheckSelect<T, PrismaPromise<Array<DetallePedido>| Null>, PrismaPromise<Array<DetallePedidoGetPayload<T>>| Null>>;

    pedidoEventos<T extends PedidoEventoFindManyArgs = {}>(args?: Subset<T, PedidoEventoFindManyArgs>): CheckSelect<T, PrismaPromise<Array<PedidoEvento>| Null>, PrismaPromise<Array<PedidoEventoGetPayload<T>>| Null>>;

    usuario<T extends UsuarioArgs = {}>(args?: Subset<T, UsuarioArgs>): CheckSelect<T, Prisma__UsuarioClient<Usuario | Null>, Prisma__UsuarioClient<UsuarioGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Pedido base type for findUnique actions
   */
  export type PedidoFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Pedido
     * 
    **/
    select?: PedidoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PedidoInclude | null
    /**
     * Filter, which Pedido to fetch.
     * 
    **/
    where: PedidoWhereUniqueInput
  }

  /**
   * Pedido: findUnique
   */
  export interface PedidoFindUniqueArgs extends PedidoFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Pedido base type for findFirst actions
   */
  export type PedidoFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Pedido
     * 
    **/
    select?: PedidoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PedidoInclude | null
    /**
     * Filter, which Pedido to fetch.
     * 
    **/
    where?: PedidoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pedidos to fetch.
     * 
    **/
    orderBy?: Enumerable<PedidoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pedidos.
     * 
    **/
    cursor?: PedidoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pedidos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pedidos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pedidos.
     * 
    **/
    distinct?: Enumerable<PedidoScalarFieldEnum>
  }

  /**
   * Pedido: findFirst
   */
  export interface PedidoFindFirstArgs extends PedidoFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Pedido findMany
   */
  export type PedidoFindManyArgs = {
    /**
     * Select specific fields to fetch from the Pedido
     * 
    **/
    select?: PedidoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PedidoInclude | null
    /**
     * Filter, which Pedidos to fetch.
     * 
    **/
    where?: PedidoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pedidos to fetch.
     * 
    **/
    orderBy?: Enumerable<PedidoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Pedidos.
     * 
    **/
    cursor?: PedidoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pedidos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pedidos.
     * 
    **/
    skip?: number
    distinct?: Enumerable<PedidoScalarFieldEnum>
  }


  /**
   * Pedido create
   */
  export type PedidoCreateArgs = {
    /**
     * Select specific fields to fetch from the Pedido
     * 
    **/
    select?: PedidoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PedidoInclude | null
    /**
     * The data needed to create a Pedido.
     * 
    **/
    data: XOR<PedidoCreateInput, PedidoUncheckedCreateInput>
  }


  /**
   * Pedido createMany
   */
  export type PedidoCreateManyArgs = {
    /**
     * The data used to create many Pedidos.
     * 
    **/
    data: Enumerable<PedidoCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Pedido update
   */
  export type PedidoUpdateArgs = {
    /**
     * Select specific fields to fetch from the Pedido
     * 
    **/
    select?: PedidoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PedidoInclude | null
    /**
     * The data needed to update a Pedido.
     * 
    **/
    data: XOR<PedidoUpdateInput, PedidoUncheckedUpdateInput>
    /**
     * Choose, which Pedido to update.
     * 
    **/
    where: PedidoWhereUniqueInput
  }


  /**
   * Pedido updateMany
   */
  export type PedidoUpdateManyArgs = {
    /**
     * The data used to update Pedidos.
     * 
    **/
    data: XOR<PedidoUpdateManyMutationInput, PedidoUncheckedUpdateManyInput>
    /**
     * Filter which Pedidos to update
     * 
    **/
    where?: PedidoWhereInput
  }


  /**
   * Pedido upsert
   */
  export type PedidoUpsertArgs = {
    /**
     * Select specific fields to fetch from the Pedido
     * 
    **/
    select?: PedidoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PedidoInclude | null
    /**
     * The filter to search for the Pedido to update in case it exists.
     * 
    **/
    where: PedidoWhereUniqueInput
    /**
     * In case the Pedido found by the `where` argument doesn't exist, create a new Pedido with this data.
     * 
    **/
    create: XOR<PedidoCreateInput, PedidoUncheckedCreateInput>
    /**
     * In case the Pedido was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<PedidoUpdateInput, PedidoUncheckedUpdateInput>
  }


  /**
   * Pedido delete
   */
  export type PedidoDeleteArgs = {
    /**
     * Select specific fields to fetch from the Pedido
     * 
    **/
    select?: PedidoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PedidoInclude | null
    /**
     * Filter which Pedido to delete.
     * 
    **/
    where: PedidoWhereUniqueInput
  }


  /**
   * Pedido deleteMany
   */
  export type PedidoDeleteManyArgs = {
    /**
     * Filter which Pedidos to delete
     * 
    **/
    where?: PedidoWhereInput
  }


  /**
   * Pedido: findUniqueOrThrow
   */
  export type PedidoFindUniqueOrThrowArgs = PedidoFindUniqueArgsBase
      

  /**
   * Pedido: findFirstOrThrow
   */
  export type PedidoFindFirstOrThrowArgs = PedidoFindFirstArgsBase
      

  /**
   * Pedido without action
   */
  export type PedidoArgs = {
    /**
     * Select specific fields to fetch from the Pedido
     * 
    **/
    select?: PedidoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PedidoInclude | null
  }



  /**
   * Model DetallePedido
   */


  export type AggregateDetallePedido = {
    _count: DetallePedidoCountAggregateOutputType | null
    _avg: DetallePedidoAvgAggregateOutputType | null
    _sum: DetallePedidoSumAggregateOutputType | null
    _min: DetallePedidoMinAggregateOutputType | null
    _max: DetallePedidoMaxAggregateOutputType | null
  }

  export type DetallePedidoAvgAggregateOutputType = {
    id: number | null
    precio: number | null
    cantidad: number | null
    productoId: number | null
    pedidoId: number | null
  }

  export type DetallePedidoSumAggregateOutputType = {
    id: number | null
    precio: number | null
    cantidad: number | null
    productoId: number | null
    pedidoId: number | null
  }

  export type DetallePedidoMinAggregateOutputType = {
    id: number | null
    precio: number | null
    cantidad: number | null
    productoId: number | null
    pedidoId: number | null
  }

  export type DetallePedidoMaxAggregateOutputType = {
    id: number | null
    precio: number | null
    cantidad: number | null
    productoId: number | null
    pedidoId: number | null
  }

  export type DetallePedidoCountAggregateOutputType = {
    id: number
    precio: number
    cantidad: number
    productoId: number
    pedidoId: number
    _all: number
  }


  export type DetallePedidoAvgAggregateInputType = {
    id?: true
    precio?: true
    cantidad?: true
    productoId?: true
    pedidoId?: true
  }

  export type DetallePedidoSumAggregateInputType = {
    id?: true
    precio?: true
    cantidad?: true
    productoId?: true
    pedidoId?: true
  }

  export type DetallePedidoMinAggregateInputType = {
    id?: true
    precio?: true
    cantidad?: true
    productoId?: true
    pedidoId?: true
  }

  export type DetallePedidoMaxAggregateInputType = {
    id?: true
    precio?: true
    cantidad?: true
    productoId?: true
    pedidoId?: true
  }

  export type DetallePedidoCountAggregateInputType = {
    id?: true
    precio?: true
    cantidad?: true
    productoId?: true
    pedidoId?: true
    _all?: true
  }

  export type DetallePedidoAggregateArgs = {
    /**
     * Filter which DetallePedido to aggregate.
     * 
    **/
    where?: DetallePedidoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DetallePedidos to fetch.
     * 
    **/
    orderBy?: Enumerable<DetallePedidoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: DetallePedidoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DetallePedidos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DetallePedidos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DetallePedidos
    **/
    _count?: true | DetallePedidoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DetallePedidoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DetallePedidoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DetallePedidoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DetallePedidoMaxAggregateInputType
  }

  export type GetDetallePedidoAggregateType<T extends DetallePedidoAggregateArgs> = {
        [P in keyof T & keyof AggregateDetallePedido]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDetallePedido[P]>
      : GetScalarType<T[P], AggregateDetallePedido[P]>
  }




  export type DetallePedidoGroupByArgs = {
    where?: DetallePedidoWhereInput
    orderBy?: Enumerable<DetallePedidoOrderByWithAggregationInput>
    by: Array<DetallePedidoScalarFieldEnum>
    having?: DetallePedidoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DetallePedidoCountAggregateInputType | true
    _avg?: DetallePedidoAvgAggregateInputType
    _sum?: DetallePedidoSumAggregateInputType
    _min?: DetallePedidoMinAggregateInputType
    _max?: DetallePedidoMaxAggregateInputType
  }


  export type DetallePedidoGroupByOutputType = {
    id: number
    precio: number
    cantidad: number
    productoId: number
    pedidoId: number
    _count: DetallePedidoCountAggregateOutputType | null
    _avg: DetallePedidoAvgAggregateOutputType | null
    _sum: DetallePedidoSumAggregateOutputType | null
    _min: DetallePedidoMinAggregateOutputType | null
    _max: DetallePedidoMaxAggregateOutputType | null
  }

  type GetDetallePedidoGroupByPayload<T extends DetallePedidoGroupByArgs> = PrismaPromise<
    Array<
      PickArray<DetallePedidoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DetallePedidoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DetallePedidoGroupByOutputType[P]>
            : GetScalarType<T[P], DetallePedidoGroupByOutputType[P]>
        }
      >
    >


  export type DetallePedidoSelect = {
    id?: boolean
    precio?: boolean
    cantidad?: boolean
    productoId?: boolean
    producto?: boolean | ProductoArgs
    pedidoId?: boolean
    pedido?: boolean | PedidoArgs
  }

  export type DetallePedidoInclude = {
    producto?: boolean | ProductoArgs
    pedido?: boolean | PedidoArgs
  }

  export type DetallePedidoGetPayload<
    S extends boolean | null | undefined | DetallePedidoArgs,
    U = keyof S
      > = S extends true
        ? DetallePedido
    : S extends undefined
    ? never
    : S extends DetallePedidoArgs | DetallePedidoFindManyArgs
    ?'include' extends U
    ? DetallePedido  & {
    [P in TrueKeys<S['include']>]:
        P extends 'producto' ? ProductoGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'pedido' ? PedidoGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'producto' ? ProductoGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'pedido' ? PedidoGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof DetallePedido ? DetallePedido[P] : never
  } 
    : DetallePedido
  : DetallePedido


  type DetallePedidoCountArgs = Merge<
    Omit<DetallePedidoFindManyArgs, 'select' | 'include'> & {
      select?: DetallePedidoCountAggregateInputType | true
    }
  >

  export interface DetallePedidoDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one DetallePedido that matches the filter.
     * @param {DetallePedidoFindUniqueArgs} args - Arguments to find a DetallePedido
     * @example
     * // Get one DetallePedido
     * const detallePedido = await prisma.detallePedido.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DetallePedidoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DetallePedidoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'DetallePedido'> extends True ? CheckSelect<T, Prisma__DetallePedidoClient<DetallePedido>, Prisma__DetallePedidoClient<DetallePedidoGetPayload<T>>> : CheckSelect<T, Prisma__DetallePedidoClient<DetallePedido | null, null>, Prisma__DetallePedidoClient<DetallePedidoGetPayload<T> | null, null>>

    /**
     * Find the first DetallePedido that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetallePedidoFindFirstArgs} args - Arguments to find a DetallePedido
     * @example
     * // Get one DetallePedido
     * const detallePedido = await prisma.detallePedido.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DetallePedidoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DetallePedidoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'DetallePedido'> extends True ? CheckSelect<T, Prisma__DetallePedidoClient<DetallePedido>, Prisma__DetallePedidoClient<DetallePedidoGetPayload<T>>> : CheckSelect<T, Prisma__DetallePedidoClient<DetallePedido | null, null>, Prisma__DetallePedidoClient<DetallePedidoGetPayload<T> | null, null>>

    /**
     * Find zero or more DetallePedidos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetallePedidoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DetallePedidos
     * const detallePedidos = await prisma.detallePedido.findMany()
     * 
     * // Get first 10 DetallePedidos
     * const detallePedidos = await prisma.detallePedido.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const detallePedidoWithIdOnly = await prisma.detallePedido.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DetallePedidoFindManyArgs>(
      args?: SelectSubset<T, DetallePedidoFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<DetallePedido>>, PrismaPromise<Array<DetallePedidoGetPayload<T>>>>

    /**
     * Create a DetallePedido.
     * @param {DetallePedidoCreateArgs} args - Arguments to create a DetallePedido.
     * @example
     * // Create one DetallePedido
     * const DetallePedido = await prisma.detallePedido.create({
     *   data: {
     *     // ... data to create a DetallePedido
     *   }
     * })
     * 
    **/
    create<T extends DetallePedidoCreateArgs>(
      args: SelectSubset<T, DetallePedidoCreateArgs>
    ): CheckSelect<T, Prisma__DetallePedidoClient<DetallePedido>, Prisma__DetallePedidoClient<DetallePedidoGetPayload<T>>>

    /**
     * Create many DetallePedidos.
     *     @param {DetallePedidoCreateManyArgs} args - Arguments to create many DetallePedidos.
     *     @example
     *     // Create many DetallePedidos
     *     const detallePedido = await prisma.detallePedido.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DetallePedidoCreateManyArgs>(
      args?: SelectSubset<T, DetallePedidoCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a DetallePedido.
     * @param {DetallePedidoDeleteArgs} args - Arguments to delete one DetallePedido.
     * @example
     * // Delete one DetallePedido
     * const DetallePedido = await prisma.detallePedido.delete({
     *   where: {
     *     // ... filter to delete one DetallePedido
     *   }
     * })
     * 
    **/
    delete<T extends DetallePedidoDeleteArgs>(
      args: SelectSubset<T, DetallePedidoDeleteArgs>
    ): CheckSelect<T, Prisma__DetallePedidoClient<DetallePedido>, Prisma__DetallePedidoClient<DetallePedidoGetPayload<T>>>

    /**
     * Update one DetallePedido.
     * @param {DetallePedidoUpdateArgs} args - Arguments to update one DetallePedido.
     * @example
     * // Update one DetallePedido
     * const detallePedido = await prisma.detallePedido.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DetallePedidoUpdateArgs>(
      args: SelectSubset<T, DetallePedidoUpdateArgs>
    ): CheckSelect<T, Prisma__DetallePedidoClient<DetallePedido>, Prisma__DetallePedidoClient<DetallePedidoGetPayload<T>>>

    /**
     * Delete zero or more DetallePedidos.
     * @param {DetallePedidoDeleteManyArgs} args - Arguments to filter DetallePedidos to delete.
     * @example
     * // Delete a few DetallePedidos
     * const { count } = await prisma.detallePedido.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DetallePedidoDeleteManyArgs>(
      args?: SelectSubset<T, DetallePedidoDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more DetallePedidos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetallePedidoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DetallePedidos
     * const detallePedido = await prisma.detallePedido.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DetallePedidoUpdateManyArgs>(
      args: SelectSubset<T, DetallePedidoUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one DetallePedido.
     * @param {DetallePedidoUpsertArgs} args - Arguments to update or create a DetallePedido.
     * @example
     * // Update or create a DetallePedido
     * const detallePedido = await prisma.detallePedido.upsert({
     *   create: {
     *     // ... data to create a DetallePedido
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DetallePedido we want to update
     *   }
     * })
    **/
    upsert<T extends DetallePedidoUpsertArgs>(
      args: SelectSubset<T, DetallePedidoUpsertArgs>
    ): CheckSelect<T, Prisma__DetallePedidoClient<DetallePedido>, Prisma__DetallePedidoClient<DetallePedidoGetPayload<T>>>

    /**
     * Find one DetallePedido that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {DetallePedidoFindUniqueOrThrowArgs} args - Arguments to find a DetallePedido
     * @example
     * // Get one DetallePedido
     * const detallePedido = await prisma.detallePedido.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DetallePedidoFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, DetallePedidoFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__DetallePedidoClient<DetallePedido>, Prisma__DetallePedidoClient<DetallePedidoGetPayload<T>>>

    /**
     * Find the first DetallePedido that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetallePedidoFindFirstOrThrowArgs} args - Arguments to find a DetallePedido
     * @example
     * // Get one DetallePedido
     * const detallePedido = await prisma.detallePedido.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DetallePedidoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, DetallePedidoFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__DetallePedidoClient<DetallePedido>, Prisma__DetallePedidoClient<DetallePedidoGetPayload<T>>>

    /**
     * Count the number of DetallePedidos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetallePedidoCountArgs} args - Arguments to filter DetallePedidos to count.
     * @example
     * // Count the number of DetallePedidos
     * const count = await prisma.detallePedido.count({
     *   where: {
     *     // ... the filter for the DetallePedidos we want to count
     *   }
     * })
    **/
    count<T extends DetallePedidoCountArgs>(
      args?: Subset<T, DetallePedidoCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DetallePedidoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DetallePedido.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetallePedidoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DetallePedidoAggregateArgs>(args: Subset<T, DetallePedidoAggregateArgs>): PrismaPromise<GetDetallePedidoAggregateType<T>>

    /**
     * Group by DetallePedido.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetallePedidoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DetallePedidoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DetallePedidoGroupByArgs['orderBy'] }
        : { orderBy?: DetallePedidoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DetallePedidoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDetallePedidoGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for DetallePedido.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DetallePedidoClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    producto<T extends ProductoArgs = {}>(args?: Subset<T, ProductoArgs>): CheckSelect<T, Prisma__ProductoClient<Producto | Null>, Prisma__ProductoClient<ProductoGetPayload<T> | Null>>;

    pedido<T extends PedidoArgs = {}>(args?: Subset<T, PedidoArgs>): CheckSelect<T, Prisma__PedidoClient<Pedido | Null>, Prisma__PedidoClient<PedidoGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * DetallePedido base type for findUnique actions
   */
  export type DetallePedidoFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the DetallePedido
     * 
    **/
    select?: DetallePedidoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DetallePedidoInclude | null
    /**
     * Filter, which DetallePedido to fetch.
     * 
    **/
    where: DetallePedidoWhereUniqueInput
  }

  /**
   * DetallePedido: findUnique
   */
  export interface DetallePedidoFindUniqueArgs extends DetallePedidoFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * DetallePedido base type for findFirst actions
   */
  export type DetallePedidoFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the DetallePedido
     * 
    **/
    select?: DetallePedidoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DetallePedidoInclude | null
    /**
     * Filter, which DetallePedido to fetch.
     * 
    **/
    where?: DetallePedidoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DetallePedidos to fetch.
     * 
    **/
    orderBy?: Enumerable<DetallePedidoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DetallePedidos.
     * 
    **/
    cursor?: DetallePedidoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DetallePedidos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DetallePedidos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DetallePedidos.
     * 
    **/
    distinct?: Enumerable<DetallePedidoScalarFieldEnum>
  }

  /**
   * DetallePedido: findFirst
   */
  export interface DetallePedidoFindFirstArgs extends DetallePedidoFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * DetallePedido findMany
   */
  export type DetallePedidoFindManyArgs = {
    /**
     * Select specific fields to fetch from the DetallePedido
     * 
    **/
    select?: DetallePedidoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DetallePedidoInclude | null
    /**
     * Filter, which DetallePedidos to fetch.
     * 
    **/
    where?: DetallePedidoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DetallePedidos to fetch.
     * 
    **/
    orderBy?: Enumerable<DetallePedidoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DetallePedidos.
     * 
    **/
    cursor?: DetallePedidoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DetallePedidos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DetallePedidos.
     * 
    **/
    skip?: number
    distinct?: Enumerable<DetallePedidoScalarFieldEnum>
  }


  /**
   * DetallePedido create
   */
  export type DetallePedidoCreateArgs = {
    /**
     * Select specific fields to fetch from the DetallePedido
     * 
    **/
    select?: DetallePedidoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DetallePedidoInclude | null
    /**
     * The data needed to create a DetallePedido.
     * 
    **/
    data: XOR<DetallePedidoCreateInput, DetallePedidoUncheckedCreateInput>
  }


  /**
   * DetallePedido createMany
   */
  export type DetallePedidoCreateManyArgs = {
    /**
     * The data used to create many DetallePedidos.
     * 
    **/
    data: Enumerable<DetallePedidoCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * DetallePedido update
   */
  export type DetallePedidoUpdateArgs = {
    /**
     * Select specific fields to fetch from the DetallePedido
     * 
    **/
    select?: DetallePedidoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DetallePedidoInclude | null
    /**
     * The data needed to update a DetallePedido.
     * 
    **/
    data: XOR<DetallePedidoUpdateInput, DetallePedidoUncheckedUpdateInput>
    /**
     * Choose, which DetallePedido to update.
     * 
    **/
    where: DetallePedidoWhereUniqueInput
  }


  /**
   * DetallePedido updateMany
   */
  export type DetallePedidoUpdateManyArgs = {
    /**
     * The data used to update DetallePedidos.
     * 
    **/
    data: XOR<DetallePedidoUpdateManyMutationInput, DetallePedidoUncheckedUpdateManyInput>
    /**
     * Filter which DetallePedidos to update
     * 
    **/
    where?: DetallePedidoWhereInput
  }


  /**
   * DetallePedido upsert
   */
  export type DetallePedidoUpsertArgs = {
    /**
     * Select specific fields to fetch from the DetallePedido
     * 
    **/
    select?: DetallePedidoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DetallePedidoInclude | null
    /**
     * The filter to search for the DetallePedido to update in case it exists.
     * 
    **/
    where: DetallePedidoWhereUniqueInput
    /**
     * In case the DetallePedido found by the `where` argument doesn't exist, create a new DetallePedido with this data.
     * 
    **/
    create: XOR<DetallePedidoCreateInput, DetallePedidoUncheckedCreateInput>
    /**
     * In case the DetallePedido was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<DetallePedidoUpdateInput, DetallePedidoUncheckedUpdateInput>
  }


  /**
   * DetallePedido delete
   */
  export type DetallePedidoDeleteArgs = {
    /**
     * Select specific fields to fetch from the DetallePedido
     * 
    **/
    select?: DetallePedidoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DetallePedidoInclude | null
    /**
     * Filter which DetallePedido to delete.
     * 
    **/
    where: DetallePedidoWhereUniqueInput
  }


  /**
   * DetallePedido deleteMany
   */
  export type DetallePedidoDeleteManyArgs = {
    /**
     * Filter which DetallePedidos to delete
     * 
    **/
    where?: DetallePedidoWhereInput
  }


  /**
   * DetallePedido: findUniqueOrThrow
   */
  export type DetallePedidoFindUniqueOrThrowArgs = DetallePedidoFindUniqueArgsBase
      

  /**
   * DetallePedido: findFirstOrThrow
   */
  export type DetallePedidoFindFirstOrThrowArgs = DetallePedidoFindFirstArgsBase
      

  /**
   * DetallePedido without action
   */
  export type DetallePedidoArgs = {
    /**
     * Select specific fields to fetch from the DetallePedido
     * 
    **/
    select?: DetallePedidoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DetallePedidoInclude | null
  }



  /**
   * Model PedidoEvento
   */


  export type AggregatePedidoEvento = {
    _count: PedidoEventoCountAggregateOutputType | null
    _avg: PedidoEventoAvgAggregateOutputType | null
    _sum: PedidoEventoSumAggregateOutputType | null
    _min: PedidoEventoMinAggregateOutputType | null
    _max: PedidoEventoMaxAggregateOutputType | null
  }

  export type PedidoEventoAvgAggregateOutputType = {
    id: number | null
    pedidoId: number | null
  }

  export type PedidoEventoSumAggregateOutputType = {
    id: number | null
    pedidoId: number | null
  }

  export type PedidoEventoMinAggregateOutputType = {
    id: number | null
    titulo: PedidoEstado | null
    fecha: Date | null
    pedidoId: number | null
  }

  export type PedidoEventoMaxAggregateOutputType = {
    id: number | null
    titulo: PedidoEstado | null
    fecha: Date | null
    pedidoId: number | null
  }

  export type PedidoEventoCountAggregateOutputType = {
    id: number
    titulo: number
    fecha: number
    pedidoId: number
    _all: number
  }


  export type PedidoEventoAvgAggregateInputType = {
    id?: true
    pedidoId?: true
  }

  export type PedidoEventoSumAggregateInputType = {
    id?: true
    pedidoId?: true
  }

  export type PedidoEventoMinAggregateInputType = {
    id?: true
    titulo?: true
    fecha?: true
    pedidoId?: true
  }

  export type PedidoEventoMaxAggregateInputType = {
    id?: true
    titulo?: true
    fecha?: true
    pedidoId?: true
  }

  export type PedidoEventoCountAggregateInputType = {
    id?: true
    titulo?: true
    fecha?: true
    pedidoId?: true
    _all?: true
  }

  export type PedidoEventoAggregateArgs = {
    /**
     * Filter which PedidoEvento to aggregate.
     * 
    **/
    where?: PedidoEventoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PedidoEventos to fetch.
     * 
    **/
    orderBy?: Enumerable<PedidoEventoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: PedidoEventoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PedidoEventos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PedidoEventos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PedidoEventos
    **/
    _count?: true | PedidoEventoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PedidoEventoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PedidoEventoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PedidoEventoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PedidoEventoMaxAggregateInputType
  }

  export type GetPedidoEventoAggregateType<T extends PedidoEventoAggregateArgs> = {
        [P in keyof T & keyof AggregatePedidoEvento]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePedidoEvento[P]>
      : GetScalarType<T[P], AggregatePedidoEvento[P]>
  }




  export type PedidoEventoGroupByArgs = {
    where?: PedidoEventoWhereInput
    orderBy?: Enumerable<PedidoEventoOrderByWithAggregationInput>
    by: Array<PedidoEventoScalarFieldEnum>
    having?: PedidoEventoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PedidoEventoCountAggregateInputType | true
    _avg?: PedidoEventoAvgAggregateInputType
    _sum?: PedidoEventoSumAggregateInputType
    _min?: PedidoEventoMinAggregateInputType
    _max?: PedidoEventoMaxAggregateInputType
  }


  export type PedidoEventoGroupByOutputType = {
    id: number
    titulo: PedidoEstado
    fecha: Date
    pedidoId: number
    _count: PedidoEventoCountAggregateOutputType | null
    _avg: PedidoEventoAvgAggregateOutputType | null
    _sum: PedidoEventoSumAggregateOutputType | null
    _min: PedidoEventoMinAggregateOutputType | null
    _max: PedidoEventoMaxAggregateOutputType | null
  }

  type GetPedidoEventoGroupByPayload<T extends PedidoEventoGroupByArgs> = PrismaPromise<
    Array<
      PickArray<PedidoEventoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PedidoEventoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PedidoEventoGroupByOutputType[P]>
            : GetScalarType<T[P], PedidoEventoGroupByOutputType[P]>
        }
      >
    >


  export type PedidoEventoSelect = {
    id?: boolean
    titulo?: boolean
    fecha?: boolean
    pedidoId?: boolean
    pedido?: boolean | PedidoArgs
  }

  export type PedidoEventoInclude = {
    pedido?: boolean | PedidoArgs
  }

  export type PedidoEventoGetPayload<
    S extends boolean | null | undefined | PedidoEventoArgs,
    U = keyof S
      > = S extends true
        ? PedidoEvento
    : S extends undefined
    ? never
    : S extends PedidoEventoArgs | PedidoEventoFindManyArgs
    ?'include' extends U
    ? PedidoEvento  & {
    [P in TrueKeys<S['include']>]:
        P extends 'pedido' ? PedidoGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'pedido' ? PedidoGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof PedidoEvento ? PedidoEvento[P] : never
  } 
    : PedidoEvento
  : PedidoEvento


  type PedidoEventoCountArgs = Merge<
    Omit<PedidoEventoFindManyArgs, 'select' | 'include'> & {
      select?: PedidoEventoCountAggregateInputType | true
    }
  >

  export interface PedidoEventoDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one PedidoEvento that matches the filter.
     * @param {PedidoEventoFindUniqueArgs} args - Arguments to find a PedidoEvento
     * @example
     * // Get one PedidoEvento
     * const pedidoEvento = await prisma.pedidoEvento.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PedidoEventoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PedidoEventoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'PedidoEvento'> extends True ? CheckSelect<T, Prisma__PedidoEventoClient<PedidoEvento>, Prisma__PedidoEventoClient<PedidoEventoGetPayload<T>>> : CheckSelect<T, Prisma__PedidoEventoClient<PedidoEvento | null, null>, Prisma__PedidoEventoClient<PedidoEventoGetPayload<T> | null, null>>

    /**
     * Find the first PedidoEvento that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoEventoFindFirstArgs} args - Arguments to find a PedidoEvento
     * @example
     * // Get one PedidoEvento
     * const pedidoEvento = await prisma.pedidoEvento.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PedidoEventoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PedidoEventoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'PedidoEvento'> extends True ? CheckSelect<T, Prisma__PedidoEventoClient<PedidoEvento>, Prisma__PedidoEventoClient<PedidoEventoGetPayload<T>>> : CheckSelect<T, Prisma__PedidoEventoClient<PedidoEvento | null, null>, Prisma__PedidoEventoClient<PedidoEventoGetPayload<T> | null, null>>

    /**
     * Find zero or more PedidoEventos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoEventoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PedidoEventos
     * const pedidoEventos = await prisma.pedidoEvento.findMany()
     * 
     * // Get first 10 PedidoEventos
     * const pedidoEventos = await prisma.pedidoEvento.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pedidoEventoWithIdOnly = await prisma.pedidoEvento.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PedidoEventoFindManyArgs>(
      args?: SelectSubset<T, PedidoEventoFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<PedidoEvento>>, PrismaPromise<Array<PedidoEventoGetPayload<T>>>>

    /**
     * Create a PedidoEvento.
     * @param {PedidoEventoCreateArgs} args - Arguments to create a PedidoEvento.
     * @example
     * // Create one PedidoEvento
     * const PedidoEvento = await prisma.pedidoEvento.create({
     *   data: {
     *     // ... data to create a PedidoEvento
     *   }
     * })
     * 
    **/
    create<T extends PedidoEventoCreateArgs>(
      args: SelectSubset<T, PedidoEventoCreateArgs>
    ): CheckSelect<T, Prisma__PedidoEventoClient<PedidoEvento>, Prisma__PedidoEventoClient<PedidoEventoGetPayload<T>>>

    /**
     * Create many PedidoEventos.
     *     @param {PedidoEventoCreateManyArgs} args - Arguments to create many PedidoEventos.
     *     @example
     *     // Create many PedidoEventos
     *     const pedidoEvento = await prisma.pedidoEvento.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PedidoEventoCreateManyArgs>(
      args?: SelectSubset<T, PedidoEventoCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a PedidoEvento.
     * @param {PedidoEventoDeleteArgs} args - Arguments to delete one PedidoEvento.
     * @example
     * // Delete one PedidoEvento
     * const PedidoEvento = await prisma.pedidoEvento.delete({
     *   where: {
     *     // ... filter to delete one PedidoEvento
     *   }
     * })
     * 
    **/
    delete<T extends PedidoEventoDeleteArgs>(
      args: SelectSubset<T, PedidoEventoDeleteArgs>
    ): CheckSelect<T, Prisma__PedidoEventoClient<PedidoEvento>, Prisma__PedidoEventoClient<PedidoEventoGetPayload<T>>>

    /**
     * Update one PedidoEvento.
     * @param {PedidoEventoUpdateArgs} args - Arguments to update one PedidoEvento.
     * @example
     * // Update one PedidoEvento
     * const pedidoEvento = await prisma.pedidoEvento.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PedidoEventoUpdateArgs>(
      args: SelectSubset<T, PedidoEventoUpdateArgs>
    ): CheckSelect<T, Prisma__PedidoEventoClient<PedidoEvento>, Prisma__PedidoEventoClient<PedidoEventoGetPayload<T>>>

    /**
     * Delete zero or more PedidoEventos.
     * @param {PedidoEventoDeleteManyArgs} args - Arguments to filter PedidoEventos to delete.
     * @example
     * // Delete a few PedidoEventos
     * const { count } = await prisma.pedidoEvento.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PedidoEventoDeleteManyArgs>(
      args?: SelectSubset<T, PedidoEventoDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more PedidoEventos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoEventoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PedidoEventos
     * const pedidoEvento = await prisma.pedidoEvento.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PedidoEventoUpdateManyArgs>(
      args: SelectSubset<T, PedidoEventoUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one PedidoEvento.
     * @param {PedidoEventoUpsertArgs} args - Arguments to update or create a PedidoEvento.
     * @example
     * // Update or create a PedidoEvento
     * const pedidoEvento = await prisma.pedidoEvento.upsert({
     *   create: {
     *     // ... data to create a PedidoEvento
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PedidoEvento we want to update
     *   }
     * })
    **/
    upsert<T extends PedidoEventoUpsertArgs>(
      args: SelectSubset<T, PedidoEventoUpsertArgs>
    ): CheckSelect<T, Prisma__PedidoEventoClient<PedidoEvento>, Prisma__PedidoEventoClient<PedidoEventoGetPayload<T>>>

    /**
     * Find one PedidoEvento that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {PedidoEventoFindUniqueOrThrowArgs} args - Arguments to find a PedidoEvento
     * @example
     * // Get one PedidoEvento
     * const pedidoEvento = await prisma.pedidoEvento.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PedidoEventoFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, PedidoEventoFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__PedidoEventoClient<PedidoEvento>, Prisma__PedidoEventoClient<PedidoEventoGetPayload<T>>>

    /**
     * Find the first PedidoEvento that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoEventoFindFirstOrThrowArgs} args - Arguments to find a PedidoEvento
     * @example
     * // Get one PedidoEvento
     * const pedidoEvento = await prisma.pedidoEvento.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PedidoEventoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PedidoEventoFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__PedidoEventoClient<PedidoEvento>, Prisma__PedidoEventoClient<PedidoEventoGetPayload<T>>>

    /**
     * Count the number of PedidoEventos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoEventoCountArgs} args - Arguments to filter PedidoEventos to count.
     * @example
     * // Count the number of PedidoEventos
     * const count = await prisma.pedidoEvento.count({
     *   where: {
     *     // ... the filter for the PedidoEventos we want to count
     *   }
     * })
    **/
    count<T extends PedidoEventoCountArgs>(
      args?: Subset<T, PedidoEventoCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PedidoEventoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PedidoEvento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoEventoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PedidoEventoAggregateArgs>(args: Subset<T, PedidoEventoAggregateArgs>): PrismaPromise<GetPedidoEventoAggregateType<T>>

    /**
     * Group by PedidoEvento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoEventoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PedidoEventoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PedidoEventoGroupByArgs['orderBy'] }
        : { orderBy?: PedidoEventoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PedidoEventoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPedidoEventoGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for PedidoEvento.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PedidoEventoClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    pedido<T extends PedidoArgs = {}>(args?: Subset<T, PedidoArgs>): CheckSelect<T, Prisma__PedidoClient<Pedido | Null>, Prisma__PedidoClient<PedidoGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * PedidoEvento base type for findUnique actions
   */
  export type PedidoEventoFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the PedidoEvento
     * 
    **/
    select?: PedidoEventoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PedidoEventoInclude | null
    /**
     * Filter, which PedidoEvento to fetch.
     * 
    **/
    where: PedidoEventoWhereUniqueInput
  }

  /**
   * PedidoEvento: findUnique
   */
  export interface PedidoEventoFindUniqueArgs extends PedidoEventoFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * PedidoEvento base type for findFirst actions
   */
  export type PedidoEventoFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the PedidoEvento
     * 
    **/
    select?: PedidoEventoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PedidoEventoInclude | null
    /**
     * Filter, which PedidoEvento to fetch.
     * 
    **/
    where?: PedidoEventoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PedidoEventos to fetch.
     * 
    **/
    orderBy?: Enumerable<PedidoEventoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PedidoEventos.
     * 
    **/
    cursor?: PedidoEventoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PedidoEventos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PedidoEventos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PedidoEventos.
     * 
    **/
    distinct?: Enumerable<PedidoEventoScalarFieldEnum>
  }

  /**
   * PedidoEvento: findFirst
   */
  export interface PedidoEventoFindFirstArgs extends PedidoEventoFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * PedidoEvento findMany
   */
  export type PedidoEventoFindManyArgs = {
    /**
     * Select specific fields to fetch from the PedidoEvento
     * 
    **/
    select?: PedidoEventoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PedidoEventoInclude | null
    /**
     * Filter, which PedidoEventos to fetch.
     * 
    **/
    where?: PedidoEventoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PedidoEventos to fetch.
     * 
    **/
    orderBy?: Enumerable<PedidoEventoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PedidoEventos.
     * 
    **/
    cursor?: PedidoEventoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PedidoEventos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PedidoEventos.
     * 
    **/
    skip?: number
    distinct?: Enumerable<PedidoEventoScalarFieldEnum>
  }


  /**
   * PedidoEvento create
   */
  export type PedidoEventoCreateArgs = {
    /**
     * Select specific fields to fetch from the PedidoEvento
     * 
    **/
    select?: PedidoEventoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PedidoEventoInclude | null
    /**
     * The data needed to create a PedidoEvento.
     * 
    **/
    data: XOR<PedidoEventoCreateInput, PedidoEventoUncheckedCreateInput>
  }


  /**
   * PedidoEvento createMany
   */
  export type PedidoEventoCreateManyArgs = {
    /**
     * The data used to create many PedidoEventos.
     * 
    **/
    data: Enumerable<PedidoEventoCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * PedidoEvento update
   */
  export type PedidoEventoUpdateArgs = {
    /**
     * Select specific fields to fetch from the PedidoEvento
     * 
    **/
    select?: PedidoEventoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PedidoEventoInclude | null
    /**
     * The data needed to update a PedidoEvento.
     * 
    **/
    data: XOR<PedidoEventoUpdateInput, PedidoEventoUncheckedUpdateInput>
    /**
     * Choose, which PedidoEvento to update.
     * 
    **/
    where: PedidoEventoWhereUniqueInput
  }


  /**
   * PedidoEvento updateMany
   */
  export type PedidoEventoUpdateManyArgs = {
    /**
     * The data used to update PedidoEventos.
     * 
    **/
    data: XOR<PedidoEventoUpdateManyMutationInput, PedidoEventoUncheckedUpdateManyInput>
    /**
     * Filter which PedidoEventos to update
     * 
    **/
    where?: PedidoEventoWhereInput
  }


  /**
   * PedidoEvento upsert
   */
  export type PedidoEventoUpsertArgs = {
    /**
     * Select specific fields to fetch from the PedidoEvento
     * 
    **/
    select?: PedidoEventoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PedidoEventoInclude | null
    /**
     * The filter to search for the PedidoEvento to update in case it exists.
     * 
    **/
    where: PedidoEventoWhereUniqueInput
    /**
     * In case the PedidoEvento found by the `where` argument doesn't exist, create a new PedidoEvento with this data.
     * 
    **/
    create: XOR<PedidoEventoCreateInput, PedidoEventoUncheckedCreateInput>
    /**
     * In case the PedidoEvento was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<PedidoEventoUpdateInput, PedidoEventoUncheckedUpdateInput>
  }


  /**
   * PedidoEvento delete
   */
  export type PedidoEventoDeleteArgs = {
    /**
     * Select specific fields to fetch from the PedidoEvento
     * 
    **/
    select?: PedidoEventoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PedidoEventoInclude | null
    /**
     * Filter which PedidoEvento to delete.
     * 
    **/
    where: PedidoEventoWhereUniqueInput
  }


  /**
   * PedidoEvento deleteMany
   */
  export type PedidoEventoDeleteManyArgs = {
    /**
     * Filter which PedidoEventos to delete
     * 
    **/
    where?: PedidoEventoWhereInput
  }


  /**
   * PedidoEvento: findUniqueOrThrow
   */
  export type PedidoEventoFindUniqueOrThrowArgs = PedidoEventoFindUniqueArgsBase
      

  /**
   * PedidoEvento: findFirstOrThrow
   */
  export type PedidoEventoFindFirstOrThrowArgs = PedidoEventoFindFirstArgsBase
      

  /**
   * PedidoEvento without action
   */
  export type PedidoEventoArgs = {
    /**
     * Select specific fields to fetch from the PedidoEvento
     * 
    **/
    select?: PedidoEventoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PedidoEventoInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const DetallePedidoScalarFieldEnum: {
    id: 'id',
    precio: 'precio',
    cantidad: 'cantidad',
    productoId: 'productoId',
    pedidoId: 'pedidoId'
  };

  export type DetallePedidoScalarFieldEnum = (typeof DetallePedidoScalarFieldEnum)[keyof typeof DetallePedidoScalarFieldEnum]


  export const DireccionScalarFieldEnum: {
    id: 'id',
    calle: 'calle',
    numero: 'numero',
    dpt: 'dpt',
    ciudad: 'ciudad',
    provincia: 'provincia',
    referencia: 'referencia',
    usuarioId: 'usuarioId'
  };

  export type DireccionScalarFieldEnum = (typeof DireccionScalarFieldEnum)[keyof typeof DireccionScalarFieldEnum]


  export const PedidoEventoScalarFieldEnum: {
    id: 'id',
    titulo: 'titulo',
    fecha: 'fecha',
    pedidoId: 'pedidoId'
  };

  export type PedidoEventoScalarFieldEnum = (typeof PedidoEventoScalarFieldEnum)[keyof typeof PedidoEventoScalarFieldEnum]


  export const PedidoScalarFieldEnum: {
    id: 'id',
    montoTotal: 'montoTotal',
    numeroSeguimiento: 'numeroSeguimiento',
    estado: 'estado',
    fecha: 'fecha',
    direccionId: 'direccionId',
    usuarioId: 'usuarioId'
  };

  export type PedidoScalarFieldEnum = (typeof PedidoScalarFieldEnum)[keyof typeof PedidoScalarFieldEnum]


  export const ProductoScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    precio: 'precio',
    unidadMedida: 'unidadMedida',
    stock: 'stock',
    imagen: 'imagen'
  };

  export type ProductoScalarFieldEnum = (typeof ProductoScalarFieldEnum)[keyof typeof ProductoScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UsuarioScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    dni: 'dni',
    correo: 'correo',
    password: 'password',
    telefono: 'telefono'
  };

  export type UsuarioScalarFieldEnum = (typeof UsuarioScalarFieldEnum)[keyof typeof UsuarioScalarFieldEnum]


  /**
   * Deep Input Types
   */


  export type ProductoWhereInput = {
    AND?: Enumerable<ProductoWhereInput>
    OR?: Enumerable<ProductoWhereInput>
    NOT?: Enumerable<ProductoWhereInput>
    id?: IntFilter | number
    nombre?: StringFilter | string
    precio?: FloatFilter | number
    unidadMedida?: StringFilter | string
    stock?: IntFilter | number
    imagen?: StringFilter | string
    detallePedidos?: DetallePedidoListRelationFilter
  }

  export type ProductoOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    precio?: SortOrder
    unidadMedida?: SortOrder
    stock?: SortOrder
    imagen?: SortOrder
    detallePedidos?: DetallePedidoOrderByRelationAggregateInput
  }

  export type ProductoWhereUniqueInput = {
    id?: number
  }

  export type ProductoOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    precio?: SortOrder
    unidadMedida?: SortOrder
    stock?: SortOrder
    imagen?: SortOrder
    _count?: ProductoCountOrderByAggregateInput
    _avg?: ProductoAvgOrderByAggregateInput
    _max?: ProductoMaxOrderByAggregateInput
    _min?: ProductoMinOrderByAggregateInput
    _sum?: ProductoSumOrderByAggregateInput
  }

  export type ProductoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ProductoScalarWhereWithAggregatesInput>
    OR?: Enumerable<ProductoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ProductoScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    nombre?: StringWithAggregatesFilter | string
    precio?: FloatWithAggregatesFilter | number
    unidadMedida?: StringWithAggregatesFilter | string
    stock?: IntWithAggregatesFilter | number
    imagen?: StringWithAggregatesFilter | string
  }

  export type UsuarioWhereInput = {
    AND?: Enumerable<UsuarioWhereInput>
    OR?: Enumerable<UsuarioWhereInput>
    NOT?: Enumerable<UsuarioWhereInput>
    id?: IntFilter | number
    nombre?: StringFilter | string
    dni?: StringFilter | string
    correo?: StringFilter | string
    password?: StringFilter | string
    telefono?: StringFilter | string
    direciones?: DireccionListRelationFilter
    pedidos?: PedidoListRelationFilter
  }

  export type UsuarioOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    dni?: SortOrder
    correo?: SortOrder
    password?: SortOrder
    telefono?: SortOrder
    direciones?: DireccionOrderByRelationAggregateInput
    pedidos?: PedidoOrderByRelationAggregateInput
  }

  export type UsuarioWhereUniqueInput = {
    id?: number
  }

  export type UsuarioOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    dni?: SortOrder
    correo?: SortOrder
    password?: SortOrder
    telefono?: SortOrder
    _count?: UsuarioCountOrderByAggregateInput
    _avg?: UsuarioAvgOrderByAggregateInput
    _max?: UsuarioMaxOrderByAggregateInput
    _min?: UsuarioMinOrderByAggregateInput
    _sum?: UsuarioSumOrderByAggregateInput
  }

  export type UsuarioScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UsuarioScalarWhereWithAggregatesInput>
    OR?: Enumerable<UsuarioScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UsuarioScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    nombre?: StringWithAggregatesFilter | string
    dni?: StringWithAggregatesFilter | string
    correo?: StringWithAggregatesFilter | string
    password?: StringWithAggregatesFilter | string
    telefono?: StringWithAggregatesFilter | string
  }

  export type DireccionWhereInput = {
    AND?: Enumerable<DireccionWhereInput>
    OR?: Enumerable<DireccionWhereInput>
    NOT?: Enumerable<DireccionWhereInput>
    id?: IntFilter | number
    calle?: StringFilter | string
    numero?: StringFilter | string
    dpt?: StringFilter | string
    ciudad?: StringFilter | string
    provincia?: StringFilter | string
    referencia?: StringNullableFilter | string | null
    usuarioId?: IntFilter | number
    usuario?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
  }

  export type DireccionOrderByWithRelationInput = {
    id?: SortOrder
    calle?: SortOrder
    numero?: SortOrder
    dpt?: SortOrder
    ciudad?: SortOrder
    provincia?: SortOrder
    referencia?: SortOrder
    usuarioId?: SortOrder
    usuario?: UsuarioOrderByWithRelationInput
  }

  export type DireccionWhereUniqueInput = {
    id?: number
  }

  export type DireccionOrderByWithAggregationInput = {
    id?: SortOrder
    calle?: SortOrder
    numero?: SortOrder
    dpt?: SortOrder
    ciudad?: SortOrder
    provincia?: SortOrder
    referencia?: SortOrder
    usuarioId?: SortOrder
    _count?: DireccionCountOrderByAggregateInput
    _avg?: DireccionAvgOrderByAggregateInput
    _max?: DireccionMaxOrderByAggregateInput
    _min?: DireccionMinOrderByAggregateInput
    _sum?: DireccionSumOrderByAggregateInput
  }

  export type DireccionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<DireccionScalarWhereWithAggregatesInput>
    OR?: Enumerable<DireccionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<DireccionScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    calle?: StringWithAggregatesFilter | string
    numero?: StringWithAggregatesFilter | string
    dpt?: StringWithAggregatesFilter | string
    ciudad?: StringWithAggregatesFilter | string
    provincia?: StringWithAggregatesFilter | string
    referencia?: StringNullableWithAggregatesFilter | string | null
    usuarioId?: IntWithAggregatesFilter | number
  }

  export type PedidoWhereInput = {
    AND?: Enumerable<PedidoWhereInput>
    OR?: Enumerable<PedidoWhereInput>
    NOT?: Enumerable<PedidoWhereInput>
    id?: IntFilter | number
    montoTotal?: FloatFilter | number
    numeroSeguimiento?: StringNullableFilter | string | null
    estado?: EnumPedidoEstadoFilter | PedidoEstado
    fecha?: DateTimeFilter | Date | string
    direccionId?: IntFilter | number
    usuarioId?: IntFilter | number
    DetallePedidos?: DetallePedidoListRelationFilter
    pedidoEventos?: PedidoEventoListRelationFilter
    usuario?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
  }

  export type PedidoOrderByWithRelationInput = {
    id?: SortOrder
    montoTotal?: SortOrder
    numeroSeguimiento?: SortOrder
    estado?: SortOrder
    fecha?: SortOrder
    direccionId?: SortOrder
    usuarioId?: SortOrder
    DetallePedidos?: DetallePedidoOrderByRelationAggregateInput
    pedidoEventos?: PedidoEventoOrderByRelationAggregateInput
    usuario?: UsuarioOrderByWithRelationInput
  }

  export type PedidoWhereUniqueInput = {
    id?: number
  }

  export type PedidoOrderByWithAggregationInput = {
    id?: SortOrder
    montoTotal?: SortOrder
    numeroSeguimiento?: SortOrder
    estado?: SortOrder
    fecha?: SortOrder
    direccionId?: SortOrder
    usuarioId?: SortOrder
    _count?: PedidoCountOrderByAggregateInput
    _avg?: PedidoAvgOrderByAggregateInput
    _max?: PedidoMaxOrderByAggregateInput
    _min?: PedidoMinOrderByAggregateInput
    _sum?: PedidoSumOrderByAggregateInput
  }

  export type PedidoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PedidoScalarWhereWithAggregatesInput>
    OR?: Enumerable<PedidoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PedidoScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    montoTotal?: FloatWithAggregatesFilter | number
    numeroSeguimiento?: StringNullableWithAggregatesFilter | string | null
    estado?: EnumPedidoEstadoWithAggregatesFilter | PedidoEstado
    fecha?: DateTimeWithAggregatesFilter | Date | string
    direccionId?: IntWithAggregatesFilter | number
    usuarioId?: IntWithAggregatesFilter | number
  }

  export type DetallePedidoWhereInput = {
    AND?: Enumerable<DetallePedidoWhereInput>
    OR?: Enumerable<DetallePedidoWhereInput>
    NOT?: Enumerable<DetallePedidoWhereInput>
    id?: IntFilter | number
    precio?: FloatFilter | number
    cantidad?: IntFilter | number
    productoId?: IntFilter | number
    producto?: XOR<ProductoRelationFilter, ProductoWhereInput>
    pedidoId?: IntFilter | number
    pedido?: XOR<PedidoRelationFilter, PedidoWhereInput>
  }

  export type DetallePedidoOrderByWithRelationInput = {
    id?: SortOrder
    precio?: SortOrder
    cantidad?: SortOrder
    productoId?: SortOrder
    producto?: ProductoOrderByWithRelationInput
    pedidoId?: SortOrder
    pedido?: PedidoOrderByWithRelationInput
  }

  export type DetallePedidoWhereUniqueInput = {
    id?: number
  }

  export type DetallePedidoOrderByWithAggregationInput = {
    id?: SortOrder
    precio?: SortOrder
    cantidad?: SortOrder
    productoId?: SortOrder
    pedidoId?: SortOrder
    _count?: DetallePedidoCountOrderByAggregateInput
    _avg?: DetallePedidoAvgOrderByAggregateInput
    _max?: DetallePedidoMaxOrderByAggregateInput
    _min?: DetallePedidoMinOrderByAggregateInput
    _sum?: DetallePedidoSumOrderByAggregateInput
  }

  export type DetallePedidoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<DetallePedidoScalarWhereWithAggregatesInput>
    OR?: Enumerable<DetallePedidoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<DetallePedidoScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    precio?: FloatWithAggregatesFilter | number
    cantidad?: IntWithAggregatesFilter | number
    productoId?: IntWithAggregatesFilter | number
    pedidoId?: IntWithAggregatesFilter | number
  }

  export type PedidoEventoWhereInput = {
    AND?: Enumerable<PedidoEventoWhereInput>
    OR?: Enumerable<PedidoEventoWhereInput>
    NOT?: Enumerable<PedidoEventoWhereInput>
    id?: IntFilter | number
    titulo?: EnumPedidoEstadoFilter | PedidoEstado
    fecha?: DateTimeFilter | Date | string
    pedidoId?: IntFilter | number
    pedido?: XOR<PedidoRelationFilter, PedidoWhereInput>
  }

  export type PedidoEventoOrderByWithRelationInput = {
    id?: SortOrder
    titulo?: SortOrder
    fecha?: SortOrder
    pedidoId?: SortOrder
    pedido?: PedidoOrderByWithRelationInput
  }

  export type PedidoEventoWhereUniqueInput = {
    id?: number
  }

  export type PedidoEventoOrderByWithAggregationInput = {
    id?: SortOrder
    titulo?: SortOrder
    fecha?: SortOrder
    pedidoId?: SortOrder
    _count?: PedidoEventoCountOrderByAggregateInput
    _avg?: PedidoEventoAvgOrderByAggregateInput
    _max?: PedidoEventoMaxOrderByAggregateInput
    _min?: PedidoEventoMinOrderByAggregateInput
    _sum?: PedidoEventoSumOrderByAggregateInput
  }

  export type PedidoEventoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PedidoEventoScalarWhereWithAggregatesInput>
    OR?: Enumerable<PedidoEventoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PedidoEventoScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    titulo?: EnumPedidoEstadoWithAggregatesFilter | PedidoEstado
    fecha?: DateTimeWithAggregatesFilter | Date | string
    pedidoId?: IntWithAggregatesFilter | number
  }

  export type ProductoCreateInput = {
    nombre: string
    precio: number
    unidadMedida: string
    stock: number
    imagen: string
    detallePedidos?: DetallePedidoCreateNestedManyWithoutProductoInput
  }

  export type ProductoUncheckedCreateInput = {
    id?: number
    nombre: string
    precio: number
    unidadMedida: string
    stock: number
    imagen: string
    detallePedidos?: DetallePedidoUncheckedCreateNestedManyWithoutProductoInput
  }

  export type ProductoUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    precio?: FloatFieldUpdateOperationsInput | number
    unidadMedida?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    imagen?: StringFieldUpdateOperationsInput | string
    detallePedidos?: DetallePedidoUpdateManyWithoutProductoNestedInput
  }

  export type ProductoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    precio?: FloatFieldUpdateOperationsInput | number
    unidadMedida?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    imagen?: StringFieldUpdateOperationsInput | string
    detallePedidos?: DetallePedidoUncheckedUpdateManyWithoutProductoNestedInput
  }

  export type ProductoCreateManyInput = {
    id?: number
    nombre: string
    precio: number
    unidadMedida: string
    stock: number
    imagen: string
  }

  export type ProductoUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    precio?: FloatFieldUpdateOperationsInput | number
    unidadMedida?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    imagen?: StringFieldUpdateOperationsInput | string
  }

  export type ProductoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    precio?: FloatFieldUpdateOperationsInput | number
    unidadMedida?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    imagen?: StringFieldUpdateOperationsInput | string
  }

  export type UsuarioCreateInput = {
    nombre: string
    dni: string
    correo: string
    password: string
    telefono: string
    direciones?: DireccionCreateNestedManyWithoutUsuarioInput
    pedidos?: PedidoCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateInput = {
    id?: number
    nombre: string
    dni: string
    correo: string
    password: string
    telefono: string
    direciones?: DireccionUncheckedCreateNestedManyWithoutUsuarioInput
    pedidos?: PedidoUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    dni?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    direciones?: DireccionUpdateManyWithoutUsuarioNestedInput
    pedidos?: PedidoUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    dni?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    direciones?: DireccionUncheckedUpdateManyWithoutUsuarioNestedInput
    pedidos?: PedidoUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioCreateManyInput = {
    id?: number
    nombre: string
    dni: string
    correo: string
    password: string
    telefono: string
  }

  export type UsuarioUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    dni?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
  }

  export type UsuarioUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    dni?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
  }

  export type DireccionCreateInput = {
    calle: string
    numero: string
    dpt: string
    ciudad: string
    provincia: string
    referencia?: string | null
    usuario: UsuarioCreateNestedOneWithoutDirecionesInput
  }

  export type DireccionUncheckedCreateInput = {
    id?: number
    calle: string
    numero: string
    dpt: string
    ciudad: string
    provincia: string
    referencia?: string | null
    usuarioId: number
  }

  export type DireccionUpdateInput = {
    calle?: StringFieldUpdateOperationsInput | string
    numero?: StringFieldUpdateOperationsInput | string
    dpt?: StringFieldUpdateOperationsInput | string
    ciudad?: StringFieldUpdateOperationsInput | string
    provincia?: StringFieldUpdateOperationsInput | string
    referencia?: NullableStringFieldUpdateOperationsInput | string | null
    usuario?: UsuarioUpdateOneRequiredWithoutDirecionesNestedInput
  }

  export type DireccionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    calle?: StringFieldUpdateOperationsInput | string
    numero?: StringFieldUpdateOperationsInput | string
    dpt?: StringFieldUpdateOperationsInput | string
    ciudad?: StringFieldUpdateOperationsInput | string
    provincia?: StringFieldUpdateOperationsInput | string
    referencia?: NullableStringFieldUpdateOperationsInput | string | null
    usuarioId?: IntFieldUpdateOperationsInput | number
  }

  export type DireccionCreateManyInput = {
    id?: number
    calle: string
    numero: string
    dpt: string
    ciudad: string
    provincia: string
    referencia?: string | null
    usuarioId: number
  }

  export type DireccionUpdateManyMutationInput = {
    calle?: StringFieldUpdateOperationsInput | string
    numero?: StringFieldUpdateOperationsInput | string
    dpt?: StringFieldUpdateOperationsInput | string
    ciudad?: StringFieldUpdateOperationsInput | string
    provincia?: StringFieldUpdateOperationsInput | string
    referencia?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DireccionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    calle?: StringFieldUpdateOperationsInput | string
    numero?: StringFieldUpdateOperationsInput | string
    dpt?: StringFieldUpdateOperationsInput | string
    ciudad?: StringFieldUpdateOperationsInput | string
    provincia?: StringFieldUpdateOperationsInput | string
    referencia?: NullableStringFieldUpdateOperationsInput | string | null
    usuarioId?: IntFieldUpdateOperationsInput | number
  }

  export type PedidoCreateInput = {
    montoTotal: number
    numeroSeguimiento?: string | null
    estado: PedidoEstado
    fecha: Date | string
    direccionId: number
    DetallePedidos?: DetallePedidoCreateNestedManyWithoutPedidoInput
    pedidoEventos?: PedidoEventoCreateNestedManyWithoutPedidoInput
    usuario: UsuarioCreateNestedOneWithoutPedidosInput
  }

  export type PedidoUncheckedCreateInput = {
    id?: number
    montoTotal: number
    numeroSeguimiento?: string | null
    estado: PedidoEstado
    fecha: Date | string
    direccionId: number
    usuarioId: number
    DetallePedidos?: DetallePedidoUncheckedCreateNestedManyWithoutPedidoInput
    pedidoEventos?: PedidoEventoUncheckedCreateNestedManyWithoutPedidoInput
  }

  export type PedidoUpdateInput = {
    montoTotal?: FloatFieldUpdateOperationsInput | number
    numeroSeguimiento?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EnumPedidoEstadoFieldUpdateOperationsInput | PedidoEstado
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    direccionId?: IntFieldUpdateOperationsInput | number
    DetallePedidos?: DetallePedidoUpdateManyWithoutPedidoNestedInput
    pedidoEventos?: PedidoEventoUpdateManyWithoutPedidoNestedInput
    usuario?: UsuarioUpdateOneRequiredWithoutPedidosNestedInput
  }

  export type PedidoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    montoTotal?: FloatFieldUpdateOperationsInput | number
    numeroSeguimiento?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EnumPedidoEstadoFieldUpdateOperationsInput | PedidoEstado
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    direccionId?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
    DetallePedidos?: DetallePedidoUncheckedUpdateManyWithoutPedidoNestedInput
    pedidoEventos?: PedidoEventoUncheckedUpdateManyWithoutPedidoNestedInput
  }

  export type PedidoCreateManyInput = {
    id?: number
    montoTotal: number
    numeroSeguimiento?: string | null
    estado: PedidoEstado
    fecha: Date | string
    direccionId: number
    usuarioId: number
  }

  export type PedidoUpdateManyMutationInput = {
    montoTotal?: FloatFieldUpdateOperationsInput | number
    numeroSeguimiento?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EnumPedidoEstadoFieldUpdateOperationsInput | PedidoEstado
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    direccionId?: IntFieldUpdateOperationsInput | number
  }

  export type PedidoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    montoTotal?: FloatFieldUpdateOperationsInput | number
    numeroSeguimiento?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EnumPedidoEstadoFieldUpdateOperationsInput | PedidoEstado
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    direccionId?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
  }

  export type DetallePedidoCreateInput = {
    precio: number
    cantidad: number
    producto: ProductoCreateNestedOneWithoutDetallePedidosInput
    pedido: PedidoCreateNestedOneWithoutDetallePedidosInput
  }

  export type DetallePedidoUncheckedCreateInput = {
    id?: number
    precio: number
    cantidad: number
    productoId: number
    pedidoId: number
  }

  export type DetallePedidoUpdateInput = {
    precio?: FloatFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
    producto?: ProductoUpdateOneRequiredWithoutDetallePedidosNestedInput
    pedido?: PedidoUpdateOneRequiredWithoutDetallePedidosNestedInput
  }

  export type DetallePedidoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    precio?: FloatFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
    productoId?: IntFieldUpdateOperationsInput | number
    pedidoId?: IntFieldUpdateOperationsInput | number
  }

  export type DetallePedidoCreateManyInput = {
    id?: number
    precio: number
    cantidad: number
    productoId: number
    pedidoId: number
  }

  export type DetallePedidoUpdateManyMutationInput = {
    precio?: FloatFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
  }

  export type DetallePedidoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    precio?: FloatFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
    productoId?: IntFieldUpdateOperationsInput | number
    pedidoId?: IntFieldUpdateOperationsInput | number
  }

  export type PedidoEventoCreateInput = {
    titulo: PedidoEstado
    fecha: Date | string
    pedido: PedidoCreateNestedOneWithoutPedidoEventosInput
  }

  export type PedidoEventoUncheckedCreateInput = {
    id?: number
    titulo: PedidoEstado
    fecha: Date | string
    pedidoId: number
  }

  export type PedidoEventoUpdateInput = {
    titulo?: EnumPedidoEstadoFieldUpdateOperationsInput | PedidoEstado
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    pedido?: PedidoUpdateOneRequiredWithoutPedidoEventosNestedInput
  }

  export type PedidoEventoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo?: EnumPedidoEstadoFieldUpdateOperationsInput | PedidoEstado
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    pedidoId?: IntFieldUpdateOperationsInput | number
  }

  export type PedidoEventoCreateManyInput = {
    id?: number
    titulo: PedidoEstado
    fecha: Date | string
    pedidoId: number
  }

  export type PedidoEventoUpdateManyMutationInput = {
    titulo?: EnumPedidoEstadoFieldUpdateOperationsInput | PedidoEstado
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PedidoEventoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo?: EnumPedidoEstadoFieldUpdateOperationsInput | PedidoEstado
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    pedidoId?: IntFieldUpdateOperationsInput | number
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type FloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type DetallePedidoListRelationFilter = {
    every?: DetallePedidoWhereInput
    some?: DetallePedidoWhereInput
    none?: DetallePedidoWhereInput
  }

  export type DetallePedidoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductoCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    precio?: SortOrder
    unidadMedida?: SortOrder
    stock?: SortOrder
    imagen?: SortOrder
  }

  export type ProductoAvgOrderByAggregateInput = {
    id?: SortOrder
    precio?: SortOrder
    stock?: SortOrder
  }

  export type ProductoMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    precio?: SortOrder
    unidadMedida?: SortOrder
    stock?: SortOrder
    imagen?: SortOrder
  }

  export type ProductoMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    precio?: SortOrder
    unidadMedida?: SortOrder
    stock?: SortOrder
    imagen?: SortOrder
  }

  export type ProductoSumOrderByAggregateInput = {
    id?: SortOrder
    precio?: SortOrder
    stock?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type FloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }

  export type DireccionListRelationFilter = {
    every?: DireccionWhereInput
    some?: DireccionWhereInput
    none?: DireccionWhereInput
  }

  export type PedidoListRelationFilter = {
    every?: PedidoWhereInput
    some?: PedidoWhereInput
    none?: PedidoWhereInput
  }

  export type DireccionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PedidoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UsuarioCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    dni?: SortOrder
    correo?: SortOrder
    password?: SortOrder
    telefono?: SortOrder
  }

  export type UsuarioAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UsuarioMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    dni?: SortOrder
    correo?: SortOrder
    password?: SortOrder
    telefono?: SortOrder
  }

  export type UsuarioMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    dni?: SortOrder
    correo?: SortOrder
    password?: SortOrder
    telefono?: SortOrder
  }

  export type UsuarioSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type UsuarioRelationFilter = {
    is?: UsuarioWhereInput
    isNot?: UsuarioWhereInput
  }

  export type DireccionCountOrderByAggregateInput = {
    id?: SortOrder
    calle?: SortOrder
    numero?: SortOrder
    dpt?: SortOrder
    ciudad?: SortOrder
    provincia?: SortOrder
    referencia?: SortOrder
    usuarioId?: SortOrder
  }

  export type DireccionAvgOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
  }

  export type DireccionMaxOrderByAggregateInput = {
    id?: SortOrder
    calle?: SortOrder
    numero?: SortOrder
    dpt?: SortOrder
    ciudad?: SortOrder
    provincia?: SortOrder
    referencia?: SortOrder
    usuarioId?: SortOrder
  }

  export type DireccionMinOrderByAggregateInput = {
    id?: SortOrder
    calle?: SortOrder
    numero?: SortOrder
    dpt?: SortOrder
    ciudad?: SortOrder
    provincia?: SortOrder
    referencia?: SortOrder
    usuarioId?: SortOrder
  }

  export type DireccionSumOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type EnumPedidoEstadoFilter = {
    equals?: PedidoEstado
    in?: Enumerable<PedidoEstado>
    notIn?: Enumerable<PedidoEstado>
    not?: NestedEnumPedidoEstadoFilter | PedidoEstado
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type PedidoEventoListRelationFilter = {
    every?: PedidoEventoWhereInput
    some?: PedidoEventoWhereInput
    none?: PedidoEventoWhereInput
  }

  export type PedidoEventoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PedidoCountOrderByAggregateInput = {
    id?: SortOrder
    montoTotal?: SortOrder
    numeroSeguimiento?: SortOrder
    estado?: SortOrder
    fecha?: SortOrder
    direccionId?: SortOrder
    usuarioId?: SortOrder
  }

  export type PedidoAvgOrderByAggregateInput = {
    id?: SortOrder
    montoTotal?: SortOrder
    direccionId?: SortOrder
    usuarioId?: SortOrder
  }

  export type PedidoMaxOrderByAggregateInput = {
    id?: SortOrder
    montoTotal?: SortOrder
    numeroSeguimiento?: SortOrder
    estado?: SortOrder
    fecha?: SortOrder
    direccionId?: SortOrder
    usuarioId?: SortOrder
  }

  export type PedidoMinOrderByAggregateInput = {
    id?: SortOrder
    montoTotal?: SortOrder
    numeroSeguimiento?: SortOrder
    estado?: SortOrder
    fecha?: SortOrder
    direccionId?: SortOrder
    usuarioId?: SortOrder
  }

  export type PedidoSumOrderByAggregateInput = {
    id?: SortOrder
    montoTotal?: SortOrder
    direccionId?: SortOrder
    usuarioId?: SortOrder
  }

  export type EnumPedidoEstadoWithAggregatesFilter = {
    equals?: PedidoEstado
    in?: Enumerable<PedidoEstado>
    notIn?: Enumerable<PedidoEstado>
    not?: NestedEnumPedidoEstadoWithAggregatesFilter | PedidoEstado
    _count?: NestedIntFilter
    _min?: NestedEnumPedidoEstadoFilter
    _max?: NestedEnumPedidoEstadoFilter
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type ProductoRelationFilter = {
    is?: ProductoWhereInput
    isNot?: ProductoWhereInput
  }

  export type PedidoRelationFilter = {
    is?: PedidoWhereInput
    isNot?: PedidoWhereInput
  }

  export type DetallePedidoCountOrderByAggregateInput = {
    id?: SortOrder
    precio?: SortOrder
    cantidad?: SortOrder
    productoId?: SortOrder
    pedidoId?: SortOrder
  }

  export type DetallePedidoAvgOrderByAggregateInput = {
    id?: SortOrder
    precio?: SortOrder
    cantidad?: SortOrder
    productoId?: SortOrder
    pedidoId?: SortOrder
  }

  export type DetallePedidoMaxOrderByAggregateInput = {
    id?: SortOrder
    precio?: SortOrder
    cantidad?: SortOrder
    productoId?: SortOrder
    pedidoId?: SortOrder
  }

  export type DetallePedidoMinOrderByAggregateInput = {
    id?: SortOrder
    precio?: SortOrder
    cantidad?: SortOrder
    productoId?: SortOrder
    pedidoId?: SortOrder
  }

  export type DetallePedidoSumOrderByAggregateInput = {
    id?: SortOrder
    precio?: SortOrder
    cantidad?: SortOrder
    productoId?: SortOrder
    pedidoId?: SortOrder
  }

  export type PedidoEventoCountOrderByAggregateInput = {
    id?: SortOrder
    titulo?: SortOrder
    fecha?: SortOrder
    pedidoId?: SortOrder
  }

  export type PedidoEventoAvgOrderByAggregateInput = {
    id?: SortOrder
    pedidoId?: SortOrder
  }

  export type PedidoEventoMaxOrderByAggregateInput = {
    id?: SortOrder
    titulo?: SortOrder
    fecha?: SortOrder
    pedidoId?: SortOrder
  }

  export type PedidoEventoMinOrderByAggregateInput = {
    id?: SortOrder
    titulo?: SortOrder
    fecha?: SortOrder
    pedidoId?: SortOrder
  }

  export type PedidoEventoSumOrderByAggregateInput = {
    id?: SortOrder
    pedidoId?: SortOrder
  }

  export type DetallePedidoCreateNestedManyWithoutProductoInput = {
    create?: XOR<Enumerable<DetallePedidoCreateWithoutProductoInput>, Enumerable<DetallePedidoUncheckedCreateWithoutProductoInput>>
    connectOrCreate?: Enumerable<DetallePedidoCreateOrConnectWithoutProductoInput>
    createMany?: DetallePedidoCreateManyProductoInputEnvelope
    connect?: Enumerable<DetallePedidoWhereUniqueInput>
  }

  export type DetallePedidoUncheckedCreateNestedManyWithoutProductoInput = {
    create?: XOR<Enumerable<DetallePedidoCreateWithoutProductoInput>, Enumerable<DetallePedidoUncheckedCreateWithoutProductoInput>>
    connectOrCreate?: Enumerable<DetallePedidoCreateOrConnectWithoutProductoInput>
    createMany?: DetallePedidoCreateManyProductoInputEnvelope
    connect?: Enumerable<DetallePedidoWhereUniqueInput>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DetallePedidoUpdateManyWithoutProductoNestedInput = {
    create?: XOR<Enumerable<DetallePedidoCreateWithoutProductoInput>, Enumerable<DetallePedidoUncheckedCreateWithoutProductoInput>>
    connectOrCreate?: Enumerable<DetallePedidoCreateOrConnectWithoutProductoInput>
    upsert?: Enumerable<DetallePedidoUpsertWithWhereUniqueWithoutProductoInput>
    createMany?: DetallePedidoCreateManyProductoInputEnvelope
    set?: Enumerable<DetallePedidoWhereUniqueInput>
    disconnect?: Enumerable<DetallePedidoWhereUniqueInput>
    delete?: Enumerable<DetallePedidoWhereUniqueInput>
    connect?: Enumerable<DetallePedidoWhereUniqueInput>
    update?: Enumerable<DetallePedidoUpdateWithWhereUniqueWithoutProductoInput>
    updateMany?: Enumerable<DetallePedidoUpdateManyWithWhereWithoutProductoInput>
    deleteMany?: Enumerable<DetallePedidoScalarWhereInput>
  }

  export type DetallePedidoUncheckedUpdateManyWithoutProductoNestedInput = {
    create?: XOR<Enumerable<DetallePedidoCreateWithoutProductoInput>, Enumerable<DetallePedidoUncheckedCreateWithoutProductoInput>>
    connectOrCreate?: Enumerable<DetallePedidoCreateOrConnectWithoutProductoInput>
    upsert?: Enumerable<DetallePedidoUpsertWithWhereUniqueWithoutProductoInput>
    createMany?: DetallePedidoCreateManyProductoInputEnvelope
    set?: Enumerable<DetallePedidoWhereUniqueInput>
    disconnect?: Enumerable<DetallePedidoWhereUniqueInput>
    delete?: Enumerable<DetallePedidoWhereUniqueInput>
    connect?: Enumerable<DetallePedidoWhereUniqueInput>
    update?: Enumerable<DetallePedidoUpdateWithWhereUniqueWithoutProductoInput>
    updateMany?: Enumerable<DetallePedidoUpdateManyWithWhereWithoutProductoInput>
    deleteMany?: Enumerable<DetallePedidoScalarWhereInput>
  }

  export type DireccionCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<Enumerable<DireccionCreateWithoutUsuarioInput>, Enumerable<DireccionUncheckedCreateWithoutUsuarioInput>>
    connectOrCreate?: Enumerable<DireccionCreateOrConnectWithoutUsuarioInput>
    createMany?: DireccionCreateManyUsuarioInputEnvelope
    connect?: Enumerable<DireccionWhereUniqueInput>
  }

  export type PedidoCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<Enumerable<PedidoCreateWithoutUsuarioInput>, Enumerable<PedidoUncheckedCreateWithoutUsuarioInput>>
    connectOrCreate?: Enumerable<PedidoCreateOrConnectWithoutUsuarioInput>
    createMany?: PedidoCreateManyUsuarioInputEnvelope
    connect?: Enumerable<PedidoWhereUniqueInput>
  }

  export type DireccionUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<Enumerable<DireccionCreateWithoutUsuarioInput>, Enumerable<DireccionUncheckedCreateWithoutUsuarioInput>>
    connectOrCreate?: Enumerable<DireccionCreateOrConnectWithoutUsuarioInput>
    createMany?: DireccionCreateManyUsuarioInputEnvelope
    connect?: Enumerable<DireccionWhereUniqueInput>
  }

  export type PedidoUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<Enumerable<PedidoCreateWithoutUsuarioInput>, Enumerable<PedidoUncheckedCreateWithoutUsuarioInput>>
    connectOrCreate?: Enumerable<PedidoCreateOrConnectWithoutUsuarioInput>
    createMany?: PedidoCreateManyUsuarioInputEnvelope
    connect?: Enumerable<PedidoWhereUniqueInput>
  }

  export type DireccionUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<Enumerable<DireccionCreateWithoutUsuarioInput>, Enumerable<DireccionUncheckedCreateWithoutUsuarioInput>>
    connectOrCreate?: Enumerable<DireccionCreateOrConnectWithoutUsuarioInput>
    upsert?: Enumerable<DireccionUpsertWithWhereUniqueWithoutUsuarioInput>
    createMany?: DireccionCreateManyUsuarioInputEnvelope
    set?: Enumerable<DireccionWhereUniqueInput>
    disconnect?: Enumerable<DireccionWhereUniqueInput>
    delete?: Enumerable<DireccionWhereUniqueInput>
    connect?: Enumerable<DireccionWhereUniqueInput>
    update?: Enumerable<DireccionUpdateWithWhereUniqueWithoutUsuarioInput>
    updateMany?: Enumerable<DireccionUpdateManyWithWhereWithoutUsuarioInput>
    deleteMany?: Enumerable<DireccionScalarWhereInput>
  }

  export type PedidoUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<Enumerable<PedidoCreateWithoutUsuarioInput>, Enumerable<PedidoUncheckedCreateWithoutUsuarioInput>>
    connectOrCreate?: Enumerable<PedidoCreateOrConnectWithoutUsuarioInput>
    upsert?: Enumerable<PedidoUpsertWithWhereUniqueWithoutUsuarioInput>
    createMany?: PedidoCreateManyUsuarioInputEnvelope
    set?: Enumerable<PedidoWhereUniqueInput>
    disconnect?: Enumerable<PedidoWhereUniqueInput>
    delete?: Enumerable<PedidoWhereUniqueInput>
    connect?: Enumerable<PedidoWhereUniqueInput>
    update?: Enumerable<PedidoUpdateWithWhereUniqueWithoutUsuarioInput>
    updateMany?: Enumerable<PedidoUpdateManyWithWhereWithoutUsuarioInput>
    deleteMany?: Enumerable<PedidoScalarWhereInput>
  }

  export type DireccionUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<Enumerable<DireccionCreateWithoutUsuarioInput>, Enumerable<DireccionUncheckedCreateWithoutUsuarioInput>>
    connectOrCreate?: Enumerable<DireccionCreateOrConnectWithoutUsuarioInput>
    upsert?: Enumerable<DireccionUpsertWithWhereUniqueWithoutUsuarioInput>
    createMany?: DireccionCreateManyUsuarioInputEnvelope
    set?: Enumerable<DireccionWhereUniqueInput>
    disconnect?: Enumerable<DireccionWhereUniqueInput>
    delete?: Enumerable<DireccionWhereUniqueInput>
    connect?: Enumerable<DireccionWhereUniqueInput>
    update?: Enumerable<DireccionUpdateWithWhereUniqueWithoutUsuarioInput>
    updateMany?: Enumerable<DireccionUpdateManyWithWhereWithoutUsuarioInput>
    deleteMany?: Enumerable<DireccionScalarWhereInput>
  }

  export type PedidoUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<Enumerable<PedidoCreateWithoutUsuarioInput>, Enumerable<PedidoUncheckedCreateWithoutUsuarioInput>>
    connectOrCreate?: Enumerable<PedidoCreateOrConnectWithoutUsuarioInput>
    upsert?: Enumerable<PedidoUpsertWithWhereUniqueWithoutUsuarioInput>
    createMany?: PedidoCreateManyUsuarioInputEnvelope
    set?: Enumerable<PedidoWhereUniqueInput>
    disconnect?: Enumerable<PedidoWhereUniqueInput>
    delete?: Enumerable<PedidoWhereUniqueInput>
    connect?: Enumerable<PedidoWhereUniqueInput>
    update?: Enumerable<PedidoUpdateWithWhereUniqueWithoutUsuarioInput>
    updateMany?: Enumerable<PedidoUpdateManyWithWhereWithoutUsuarioInput>
    deleteMany?: Enumerable<PedidoScalarWhereInput>
  }

  export type UsuarioCreateNestedOneWithoutDirecionesInput = {
    create?: XOR<UsuarioCreateWithoutDirecionesInput, UsuarioUncheckedCreateWithoutDirecionesInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutDirecionesInput
    connect?: UsuarioWhereUniqueInput
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type UsuarioUpdateOneRequiredWithoutDirecionesNestedInput = {
    create?: XOR<UsuarioCreateWithoutDirecionesInput, UsuarioUncheckedCreateWithoutDirecionesInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutDirecionesInput
    upsert?: UsuarioUpsertWithoutDirecionesInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<UsuarioUpdateWithoutDirecionesInput, UsuarioUncheckedUpdateWithoutDirecionesInput>
  }

  export type DetallePedidoCreateNestedManyWithoutPedidoInput = {
    create?: XOR<Enumerable<DetallePedidoCreateWithoutPedidoInput>, Enumerable<DetallePedidoUncheckedCreateWithoutPedidoInput>>
    connectOrCreate?: Enumerable<DetallePedidoCreateOrConnectWithoutPedidoInput>
    createMany?: DetallePedidoCreateManyPedidoInputEnvelope
    connect?: Enumerable<DetallePedidoWhereUniqueInput>
  }

  export type PedidoEventoCreateNestedManyWithoutPedidoInput = {
    create?: XOR<Enumerable<PedidoEventoCreateWithoutPedidoInput>, Enumerable<PedidoEventoUncheckedCreateWithoutPedidoInput>>
    connectOrCreate?: Enumerable<PedidoEventoCreateOrConnectWithoutPedidoInput>
    createMany?: PedidoEventoCreateManyPedidoInputEnvelope
    connect?: Enumerable<PedidoEventoWhereUniqueInput>
  }

  export type UsuarioCreateNestedOneWithoutPedidosInput = {
    create?: XOR<UsuarioCreateWithoutPedidosInput, UsuarioUncheckedCreateWithoutPedidosInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutPedidosInput
    connect?: UsuarioWhereUniqueInput
  }

  export type DetallePedidoUncheckedCreateNestedManyWithoutPedidoInput = {
    create?: XOR<Enumerable<DetallePedidoCreateWithoutPedidoInput>, Enumerable<DetallePedidoUncheckedCreateWithoutPedidoInput>>
    connectOrCreate?: Enumerable<DetallePedidoCreateOrConnectWithoutPedidoInput>
    createMany?: DetallePedidoCreateManyPedidoInputEnvelope
    connect?: Enumerable<DetallePedidoWhereUniqueInput>
  }

  export type PedidoEventoUncheckedCreateNestedManyWithoutPedidoInput = {
    create?: XOR<Enumerable<PedidoEventoCreateWithoutPedidoInput>, Enumerable<PedidoEventoUncheckedCreateWithoutPedidoInput>>
    connectOrCreate?: Enumerable<PedidoEventoCreateOrConnectWithoutPedidoInput>
    createMany?: PedidoEventoCreateManyPedidoInputEnvelope
    connect?: Enumerable<PedidoEventoWhereUniqueInput>
  }

  export type EnumPedidoEstadoFieldUpdateOperationsInput = {
    set?: PedidoEstado
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type DetallePedidoUpdateManyWithoutPedidoNestedInput = {
    create?: XOR<Enumerable<DetallePedidoCreateWithoutPedidoInput>, Enumerable<DetallePedidoUncheckedCreateWithoutPedidoInput>>
    connectOrCreate?: Enumerable<DetallePedidoCreateOrConnectWithoutPedidoInput>
    upsert?: Enumerable<DetallePedidoUpsertWithWhereUniqueWithoutPedidoInput>
    createMany?: DetallePedidoCreateManyPedidoInputEnvelope
    set?: Enumerable<DetallePedidoWhereUniqueInput>
    disconnect?: Enumerable<DetallePedidoWhereUniqueInput>
    delete?: Enumerable<DetallePedidoWhereUniqueInput>
    connect?: Enumerable<DetallePedidoWhereUniqueInput>
    update?: Enumerable<DetallePedidoUpdateWithWhereUniqueWithoutPedidoInput>
    updateMany?: Enumerable<DetallePedidoUpdateManyWithWhereWithoutPedidoInput>
    deleteMany?: Enumerable<DetallePedidoScalarWhereInput>
  }

  export type PedidoEventoUpdateManyWithoutPedidoNestedInput = {
    create?: XOR<Enumerable<PedidoEventoCreateWithoutPedidoInput>, Enumerable<PedidoEventoUncheckedCreateWithoutPedidoInput>>
    connectOrCreate?: Enumerable<PedidoEventoCreateOrConnectWithoutPedidoInput>
    upsert?: Enumerable<PedidoEventoUpsertWithWhereUniqueWithoutPedidoInput>
    createMany?: PedidoEventoCreateManyPedidoInputEnvelope
    set?: Enumerable<PedidoEventoWhereUniqueInput>
    disconnect?: Enumerable<PedidoEventoWhereUniqueInput>
    delete?: Enumerable<PedidoEventoWhereUniqueInput>
    connect?: Enumerable<PedidoEventoWhereUniqueInput>
    update?: Enumerable<PedidoEventoUpdateWithWhereUniqueWithoutPedidoInput>
    updateMany?: Enumerable<PedidoEventoUpdateManyWithWhereWithoutPedidoInput>
    deleteMany?: Enumerable<PedidoEventoScalarWhereInput>
  }

  export type UsuarioUpdateOneRequiredWithoutPedidosNestedInput = {
    create?: XOR<UsuarioCreateWithoutPedidosInput, UsuarioUncheckedCreateWithoutPedidosInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutPedidosInput
    upsert?: UsuarioUpsertWithoutPedidosInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<UsuarioUpdateWithoutPedidosInput, UsuarioUncheckedUpdateWithoutPedidosInput>
  }

  export type DetallePedidoUncheckedUpdateManyWithoutPedidoNestedInput = {
    create?: XOR<Enumerable<DetallePedidoCreateWithoutPedidoInput>, Enumerable<DetallePedidoUncheckedCreateWithoutPedidoInput>>
    connectOrCreate?: Enumerable<DetallePedidoCreateOrConnectWithoutPedidoInput>
    upsert?: Enumerable<DetallePedidoUpsertWithWhereUniqueWithoutPedidoInput>
    createMany?: DetallePedidoCreateManyPedidoInputEnvelope
    set?: Enumerable<DetallePedidoWhereUniqueInput>
    disconnect?: Enumerable<DetallePedidoWhereUniqueInput>
    delete?: Enumerable<DetallePedidoWhereUniqueInput>
    connect?: Enumerable<DetallePedidoWhereUniqueInput>
    update?: Enumerable<DetallePedidoUpdateWithWhereUniqueWithoutPedidoInput>
    updateMany?: Enumerable<DetallePedidoUpdateManyWithWhereWithoutPedidoInput>
    deleteMany?: Enumerable<DetallePedidoScalarWhereInput>
  }

  export type PedidoEventoUncheckedUpdateManyWithoutPedidoNestedInput = {
    create?: XOR<Enumerable<PedidoEventoCreateWithoutPedidoInput>, Enumerable<PedidoEventoUncheckedCreateWithoutPedidoInput>>
    connectOrCreate?: Enumerable<PedidoEventoCreateOrConnectWithoutPedidoInput>
    upsert?: Enumerable<PedidoEventoUpsertWithWhereUniqueWithoutPedidoInput>
    createMany?: PedidoEventoCreateManyPedidoInputEnvelope
    set?: Enumerable<PedidoEventoWhereUniqueInput>
    disconnect?: Enumerable<PedidoEventoWhereUniqueInput>
    delete?: Enumerable<PedidoEventoWhereUniqueInput>
    connect?: Enumerable<PedidoEventoWhereUniqueInput>
    update?: Enumerable<PedidoEventoUpdateWithWhereUniqueWithoutPedidoInput>
    updateMany?: Enumerable<PedidoEventoUpdateManyWithWhereWithoutPedidoInput>
    deleteMany?: Enumerable<PedidoEventoScalarWhereInput>
  }

  export type ProductoCreateNestedOneWithoutDetallePedidosInput = {
    create?: XOR<ProductoCreateWithoutDetallePedidosInput, ProductoUncheckedCreateWithoutDetallePedidosInput>
    connectOrCreate?: ProductoCreateOrConnectWithoutDetallePedidosInput
    connect?: ProductoWhereUniqueInput
  }

  export type PedidoCreateNestedOneWithoutDetallePedidosInput = {
    create?: XOR<PedidoCreateWithoutDetallePedidosInput, PedidoUncheckedCreateWithoutDetallePedidosInput>
    connectOrCreate?: PedidoCreateOrConnectWithoutDetallePedidosInput
    connect?: PedidoWhereUniqueInput
  }

  export type ProductoUpdateOneRequiredWithoutDetallePedidosNestedInput = {
    create?: XOR<ProductoCreateWithoutDetallePedidosInput, ProductoUncheckedCreateWithoutDetallePedidosInput>
    connectOrCreate?: ProductoCreateOrConnectWithoutDetallePedidosInput
    upsert?: ProductoUpsertWithoutDetallePedidosInput
    connect?: ProductoWhereUniqueInput
    update?: XOR<ProductoUpdateWithoutDetallePedidosInput, ProductoUncheckedUpdateWithoutDetallePedidosInput>
  }

  export type PedidoUpdateOneRequiredWithoutDetallePedidosNestedInput = {
    create?: XOR<PedidoCreateWithoutDetallePedidosInput, PedidoUncheckedCreateWithoutDetallePedidosInput>
    connectOrCreate?: PedidoCreateOrConnectWithoutDetallePedidosInput
    upsert?: PedidoUpsertWithoutDetallePedidosInput
    connect?: PedidoWhereUniqueInput
    update?: XOR<PedidoUpdateWithoutDetallePedidosInput, PedidoUncheckedUpdateWithoutDetallePedidosInput>
  }

  export type PedidoCreateNestedOneWithoutPedidoEventosInput = {
    create?: XOR<PedidoCreateWithoutPedidoEventosInput, PedidoUncheckedCreateWithoutPedidoEventosInput>
    connectOrCreate?: PedidoCreateOrConnectWithoutPedidoEventosInput
    connect?: PedidoWhereUniqueInput
  }

  export type PedidoUpdateOneRequiredWithoutPedidoEventosNestedInput = {
    create?: XOR<PedidoCreateWithoutPedidoEventosInput, PedidoUncheckedCreateWithoutPedidoEventosInput>
    connectOrCreate?: PedidoCreateOrConnectWithoutPedidoEventosInput
    upsert?: PedidoUpsertWithoutPedidoEventosInput
    connect?: PedidoWhereUniqueInput
    update?: XOR<PedidoUpdateWithoutPedidoEventosInput, PedidoUncheckedUpdateWithoutPedidoEventosInput>
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedFloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedEnumPedidoEstadoFilter = {
    equals?: PedidoEstado
    in?: Enumerable<PedidoEstado>
    notIn?: Enumerable<PedidoEstado>
    not?: NestedEnumPedidoEstadoFilter | PedidoEstado
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedEnumPedidoEstadoWithAggregatesFilter = {
    equals?: PedidoEstado
    in?: Enumerable<PedidoEstado>
    notIn?: Enumerable<PedidoEstado>
    not?: NestedEnumPedidoEstadoWithAggregatesFilter | PedidoEstado
    _count?: NestedIntFilter
    _min?: NestedEnumPedidoEstadoFilter
    _max?: NestedEnumPedidoEstadoFilter
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type DetallePedidoCreateWithoutProductoInput = {
    precio: number
    cantidad: number
    pedido: PedidoCreateNestedOneWithoutDetallePedidosInput
  }

  export type DetallePedidoUncheckedCreateWithoutProductoInput = {
    id?: number
    precio: number
    cantidad: number
    pedidoId: number
  }

  export type DetallePedidoCreateOrConnectWithoutProductoInput = {
    where: DetallePedidoWhereUniqueInput
    create: XOR<DetallePedidoCreateWithoutProductoInput, DetallePedidoUncheckedCreateWithoutProductoInput>
  }

  export type DetallePedidoCreateManyProductoInputEnvelope = {
    data: Enumerable<DetallePedidoCreateManyProductoInput>
    skipDuplicates?: boolean
  }

  export type DetallePedidoUpsertWithWhereUniqueWithoutProductoInput = {
    where: DetallePedidoWhereUniqueInput
    update: XOR<DetallePedidoUpdateWithoutProductoInput, DetallePedidoUncheckedUpdateWithoutProductoInput>
    create: XOR<DetallePedidoCreateWithoutProductoInput, DetallePedidoUncheckedCreateWithoutProductoInput>
  }

  export type DetallePedidoUpdateWithWhereUniqueWithoutProductoInput = {
    where: DetallePedidoWhereUniqueInput
    data: XOR<DetallePedidoUpdateWithoutProductoInput, DetallePedidoUncheckedUpdateWithoutProductoInput>
  }

  export type DetallePedidoUpdateManyWithWhereWithoutProductoInput = {
    where: DetallePedidoScalarWhereInput
    data: XOR<DetallePedidoUpdateManyMutationInput, DetallePedidoUncheckedUpdateManyWithoutDetallePedidosInput>
  }

  export type DetallePedidoScalarWhereInput = {
    AND?: Enumerable<DetallePedidoScalarWhereInput>
    OR?: Enumerable<DetallePedidoScalarWhereInput>
    NOT?: Enumerable<DetallePedidoScalarWhereInput>
    id?: IntFilter | number
    precio?: FloatFilter | number
    cantidad?: IntFilter | number
    productoId?: IntFilter | number
    pedidoId?: IntFilter | number
  }

  export type DireccionCreateWithoutUsuarioInput = {
    calle: string
    numero: string
    dpt: string
    ciudad: string
    provincia: string
    referencia?: string | null
  }

  export type DireccionUncheckedCreateWithoutUsuarioInput = {
    id?: number
    calle: string
    numero: string
    dpt: string
    ciudad: string
    provincia: string
    referencia?: string | null
  }

  export type DireccionCreateOrConnectWithoutUsuarioInput = {
    where: DireccionWhereUniqueInput
    create: XOR<DireccionCreateWithoutUsuarioInput, DireccionUncheckedCreateWithoutUsuarioInput>
  }

  export type DireccionCreateManyUsuarioInputEnvelope = {
    data: Enumerable<DireccionCreateManyUsuarioInput>
    skipDuplicates?: boolean
  }

  export type PedidoCreateWithoutUsuarioInput = {
    montoTotal: number
    numeroSeguimiento?: string | null
    estado: PedidoEstado
    fecha: Date | string
    direccionId: number
    DetallePedidos?: DetallePedidoCreateNestedManyWithoutPedidoInput
    pedidoEventos?: PedidoEventoCreateNestedManyWithoutPedidoInput
  }

  export type PedidoUncheckedCreateWithoutUsuarioInput = {
    id?: number
    montoTotal: number
    numeroSeguimiento?: string | null
    estado: PedidoEstado
    fecha: Date | string
    direccionId: number
    DetallePedidos?: DetallePedidoUncheckedCreateNestedManyWithoutPedidoInput
    pedidoEventos?: PedidoEventoUncheckedCreateNestedManyWithoutPedidoInput
  }

  export type PedidoCreateOrConnectWithoutUsuarioInput = {
    where: PedidoWhereUniqueInput
    create: XOR<PedidoCreateWithoutUsuarioInput, PedidoUncheckedCreateWithoutUsuarioInput>
  }

  export type PedidoCreateManyUsuarioInputEnvelope = {
    data: Enumerable<PedidoCreateManyUsuarioInput>
    skipDuplicates?: boolean
  }

  export type DireccionUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: DireccionWhereUniqueInput
    update: XOR<DireccionUpdateWithoutUsuarioInput, DireccionUncheckedUpdateWithoutUsuarioInput>
    create: XOR<DireccionCreateWithoutUsuarioInput, DireccionUncheckedCreateWithoutUsuarioInput>
  }

  export type DireccionUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: DireccionWhereUniqueInput
    data: XOR<DireccionUpdateWithoutUsuarioInput, DireccionUncheckedUpdateWithoutUsuarioInput>
  }

  export type DireccionUpdateManyWithWhereWithoutUsuarioInput = {
    where: DireccionScalarWhereInput
    data: XOR<DireccionUpdateManyMutationInput, DireccionUncheckedUpdateManyWithoutDirecionesInput>
  }

  export type DireccionScalarWhereInput = {
    AND?: Enumerable<DireccionScalarWhereInput>
    OR?: Enumerable<DireccionScalarWhereInput>
    NOT?: Enumerable<DireccionScalarWhereInput>
    id?: IntFilter | number
    calle?: StringFilter | string
    numero?: StringFilter | string
    dpt?: StringFilter | string
    ciudad?: StringFilter | string
    provincia?: StringFilter | string
    referencia?: StringNullableFilter | string | null
    usuarioId?: IntFilter | number
  }

  export type PedidoUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: PedidoWhereUniqueInput
    update: XOR<PedidoUpdateWithoutUsuarioInput, PedidoUncheckedUpdateWithoutUsuarioInput>
    create: XOR<PedidoCreateWithoutUsuarioInput, PedidoUncheckedCreateWithoutUsuarioInput>
  }

  export type PedidoUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: PedidoWhereUniqueInput
    data: XOR<PedidoUpdateWithoutUsuarioInput, PedidoUncheckedUpdateWithoutUsuarioInput>
  }

  export type PedidoUpdateManyWithWhereWithoutUsuarioInput = {
    where: PedidoScalarWhereInput
    data: XOR<PedidoUpdateManyMutationInput, PedidoUncheckedUpdateManyWithoutPedidosInput>
  }

  export type PedidoScalarWhereInput = {
    AND?: Enumerable<PedidoScalarWhereInput>
    OR?: Enumerable<PedidoScalarWhereInput>
    NOT?: Enumerable<PedidoScalarWhereInput>
    id?: IntFilter | number
    montoTotal?: FloatFilter | number
    numeroSeguimiento?: StringNullableFilter | string | null
    estado?: EnumPedidoEstadoFilter | PedidoEstado
    fecha?: DateTimeFilter | Date | string
    direccionId?: IntFilter | number
    usuarioId?: IntFilter | number
  }

  export type UsuarioCreateWithoutDirecionesInput = {
    nombre: string
    dni: string
    correo: string
    password: string
    telefono: string
    pedidos?: PedidoCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutDirecionesInput = {
    id?: number
    nombre: string
    dni: string
    correo: string
    password: string
    telefono: string
    pedidos?: PedidoUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutDirecionesInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutDirecionesInput, UsuarioUncheckedCreateWithoutDirecionesInput>
  }

  export type UsuarioUpsertWithoutDirecionesInput = {
    update: XOR<UsuarioUpdateWithoutDirecionesInput, UsuarioUncheckedUpdateWithoutDirecionesInput>
    create: XOR<UsuarioCreateWithoutDirecionesInput, UsuarioUncheckedCreateWithoutDirecionesInput>
  }

  export type UsuarioUpdateWithoutDirecionesInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    dni?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    pedidos?: PedidoUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutDirecionesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    dni?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    pedidos?: PedidoUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type DetallePedidoCreateWithoutPedidoInput = {
    precio: number
    cantidad: number
    producto: ProductoCreateNestedOneWithoutDetallePedidosInput
  }

  export type DetallePedidoUncheckedCreateWithoutPedidoInput = {
    id?: number
    precio: number
    cantidad: number
    productoId: number
  }

  export type DetallePedidoCreateOrConnectWithoutPedidoInput = {
    where: DetallePedidoWhereUniqueInput
    create: XOR<DetallePedidoCreateWithoutPedidoInput, DetallePedidoUncheckedCreateWithoutPedidoInput>
  }

  export type DetallePedidoCreateManyPedidoInputEnvelope = {
    data: Enumerable<DetallePedidoCreateManyPedidoInput>
    skipDuplicates?: boolean
  }

  export type PedidoEventoCreateWithoutPedidoInput = {
    titulo: PedidoEstado
    fecha: Date | string
  }

  export type PedidoEventoUncheckedCreateWithoutPedidoInput = {
    id?: number
    titulo: PedidoEstado
    fecha: Date | string
  }

  export type PedidoEventoCreateOrConnectWithoutPedidoInput = {
    where: PedidoEventoWhereUniqueInput
    create: XOR<PedidoEventoCreateWithoutPedidoInput, PedidoEventoUncheckedCreateWithoutPedidoInput>
  }

  export type PedidoEventoCreateManyPedidoInputEnvelope = {
    data: Enumerable<PedidoEventoCreateManyPedidoInput>
    skipDuplicates?: boolean
  }

  export type UsuarioCreateWithoutPedidosInput = {
    nombre: string
    dni: string
    correo: string
    password: string
    telefono: string
    direciones?: DireccionCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutPedidosInput = {
    id?: number
    nombre: string
    dni: string
    correo: string
    password: string
    telefono: string
    direciones?: DireccionUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutPedidosInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutPedidosInput, UsuarioUncheckedCreateWithoutPedidosInput>
  }

  export type DetallePedidoUpsertWithWhereUniqueWithoutPedidoInput = {
    where: DetallePedidoWhereUniqueInput
    update: XOR<DetallePedidoUpdateWithoutPedidoInput, DetallePedidoUncheckedUpdateWithoutPedidoInput>
    create: XOR<DetallePedidoCreateWithoutPedidoInput, DetallePedidoUncheckedCreateWithoutPedidoInput>
  }

  export type DetallePedidoUpdateWithWhereUniqueWithoutPedidoInput = {
    where: DetallePedidoWhereUniqueInput
    data: XOR<DetallePedidoUpdateWithoutPedidoInput, DetallePedidoUncheckedUpdateWithoutPedidoInput>
  }

  export type DetallePedidoUpdateManyWithWhereWithoutPedidoInput = {
    where: DetallePedidoScalarWhereInput
    data: XOR<DetallePedidoUpdateManyMutationInput, DetallePedidoUncheckedUpdateManyWithoutDetallePedidosInput>
  }

  export type PedidoEventoUpsertWithWhereUniqueWithoutPedidoInput = {
    where: PedidoEventoWhereUniqueInput
    update: XOR<PedidoEventoUpdateWithoutPedidoInput, PedidoEventoUncheckedUpdateWithoutPedidoInput>
    create: XOR<PedidoEventoCreateWithoutPedidoInput, PedidoEventoUncheckedCreateWithoutPedidoInput>
  }

  export type PedidoEventoUpdateWithWhereUniqueWithoutPedidoInput = {
    where: PedidoEventoWhereUniqueInput
    data: XOR<PedidoEventoUpdateWithoutPedidoInput, PedidoEventoUncheckedUpdateWithoutPedidoInput>
  }

  export type PedidoEventoUpdateManyWithWhereWithoutPedidoInput = {
    where: PedidoEventoScalarWhereInput
    data: XOR<PedidoEventoUpdateManyMutationInput, PedidoEventoUncheckedUpdateManyWithoutPedidoEventosInput>
  }

  export type PedidoEventoScalarWhereInput = {
    AND?: Enumerable<PedidoEventoScalarWhereInput>
    OR?: Enumerable<PedidoEventoScalarWhereInput>
    NOT?: Enumerable<PedidoEventoScalarWhereInput>
    id?: IntFilter | number
    titulo?: EnumPedidoEstadoFilter | PedidoEstado
    fecha?: DateTimeFilter | Date | string
    pedidoId?: IntFilter | number
  }

  export type UsuarioUpsertWithoutPedidosInput = {
    update: XOR<UsuarioUpdateWithoutPedidosInput, UsuarioUncheckedUpdateWithoutPedidosInput>
    create: XOR<UsuarioCreateWithoutPedidosInput, UsuarioUncheckedCreateWithoutPedidosInput>
  }

  export type UsuarioUpdateWithoutPedidosInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    dni?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    direciones?: DireccionUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutPedidosInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    dni?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    direciones?: DireccionUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type ProductoCreateWithoutDetallePedidosInput = {
    nombre: string
    precio: number
    unidadMedida: string
    stock: number
    imagen: string
  }

  export type ProductoUncheckedCreateWithoutDetallePedidosInput = {
    id?: number
    nombre: string
    precio: number
    unidadMedida: string
    stock: number
    imagen: string
  }

  export type ProductoCreateOrConnectWithoutDetallePedidosInput = {
    where: ProductoWhereUniqueInput
    create: XOR<ProductoCreateWithoutDetallePedidosInput, ProductoUncheckedCreateWithoutDetallePedidosInput>
  }

  export type PedidoCreateWithoutDetallePedidosInput = {
    montoTotal: number
    numeroSeguimiento?: string | null
    estado: PedidoEstado
    fecha: Date | string
    direccionId: number
    pedidoEventos?: PedidoEventoCreateNestedManyWithoutPedidoInput
    usuario: UsuarioCreateNestedOneWithoutPedidosInput
  }

  export type PedidoUncheckedCreateWithoutDetallePedidosInput = {
    id?: number
    montoTotal: number
    numeroSeguimiento?: string | null
    estado: PedidoEstado
    fecha: Date | string
    direccionId: number
    usuarioId: number
    pedidoEventos?: PedidoEventoUncheckedCreateNestedManyWithoutPedidoInput
  }

  export type PedidoCreateOrConnectWithoutDetallePedidosInput = {
    where: PedidoWhereUniqueInput
    create: XOR<PedidoCreateWithoutDetallePedidosInput, PedidoUncheckedCreateWithoutDetallePedidosInput>
  }

  export type ProductoUpsertWithoutDetallePedidosInput = {
    update: XOR<ProductoUpdateWithoutDetallePedidosInput, ProductoUncheckedUpdateWithoutDetallePedidosInput>
    create: XOR<ProductoCreateWithoutDetallePedidosInput, ProductoUncheckedCreateWithoutDetallePedidosInput>
  }

  export type ProductoUpdateWithoutDetallePedidosInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    precio?: FloatFieldUpdateOperationsInput | number
    unidadMedida?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    imagen?: StringFieldUpdateOperationsInput | string
  }

  export type ProductoUncheckedUpdateWithoutDetallePedidosInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    precio?: FloatFieldUpdateOperationsInput | number
    unidadMedida?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    imagen?: StringFieldUpdateOperationsInput | string
  }

  export type PedidoUpsertWithoutDetallePedidosInput = {
    update: XOR<PedidoUpdateWithoutDetallePedidosInput, PedidoUncheckedUpdateWithoutDetallePedidosInput>
    create: XOR<PedidoCreateWithoutDetallePedidosInput, PedidoUncheckedCreateWithoutDetallePedidosInput>
  }

  export type PedidoUpdateWithoutDetallePedidosInput = {
    montoTotal?: FloatFieldUpdateOperationsInput | number
    numeroSeguimiento?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EnumPedidoEstadoFieldUpdateOperationsInput | PedidoEstado
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    direccionId?: IntFieldUpdateOperationsInput | number
    pedidoEventos?: PedidoEventoUpdateManyWithoutPedidoNestedInput
    usuario?: UsuarioUpdateOneRequiredWithoutPedidosNestedInput
  }

  export type PedidoUncheckedUpdateWithoutDetallePedidosInput = {
    id?: IntFieldUpdateOperationsInput | number
    montoTotal?: FloatFieldUpdateOperationsInput | number
    numeroSeguimiento?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EnumPedidoEstadoFieldUpdateOperationsInput | PedidoEstado
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    direccionId?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
    pedidoEventos?: PedidoEventoUncheckedUpdateManyWithoutPedidoNestedInput
  }

  export type PedidoCreateWithoutPedidoEventosInput = {
    montoTotal: number
    numeroSeguimiento?: string | null
    estado: PedidoEstado
    fecha: Date | string
    direccionId: number
    DetallePedidos?: DetallePedidoCreateNestedManyWithoutPedidoInput
    usuario: UsuarioCreateNestedOneWithoutPedidosInput
  }

  export type PedidoUncheckedCreateWithoutPedidoEventosInput = {
    id?: number
    montoTotal: number
    numeroSeguimiento?: string | null
    estado: PedidoEstado
    fecha: Date | string
    direccionId: number
    usuarioId: number
    DetallePedidos?: DetallePedidoUncheckedCreateNestedManyWithoutPedidoInput
  }

  export type PedidoCreateOrConnectWithoutPedidoEventosInput = {
    where: PedidoWhereUniqueInput
    create: XOR<PedidoCreateWithoutPedidoEventosInput, PedidoUncheckedCreateWithoutPedidoEventosInput>
  }

  export type PedidoUpsertWithoutPedidoEventosInput = {
    update: XOR<PedidoUpdateWithoutPedidoEventosInput, PedidoUncheckedUpdateWithoutPedidoEventosInput>
    create: XOR<PedidoCreateWithoutPedidoEventosInput, PedidoUncheckedCreateWithoutPedidoEventosInput>
  }

  export type PedidoUpdateWithoutPedidoEventosInput = {
    montoTotal?: FloatFieldUpdateOperationsInput | number
    numeroSeguimiento?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EnumPedidoEstadoFieldUpdateOperationsInput | PedidoEstado
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    direccionId?: IntFieldUpdateOperationsInput | number
    DetallePedidos?: DetallePedidoUpdateManyWithoutPedidoNestedInput
    usuario?: UsuarioUpdateOneRequiredWithoutPedidosNestedInput
  }

  export type PedidoUncheckedUpdateWithoutPedidoEventosInput = {
    id?: IntFieldUpdateOperationsInput | number
    montoTotal?: FloatFieldUpdateOperationsInput | number
    numeroSeguimiento?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EnumPedidoEstadoFieldUpdateOperationsInput | PedidoEstado
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    direccionId?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
    DetallePedidos?: DetallePedidoUncheckedUpdateManyWithoutPedidoNestedInput
  }

  export type DetallePedidoCreateManyProductoInput = {
    id?: number
    precio: number
    cantidad: number
    pedidoId: number
  }

  export type DetallePedidoUpdateWithoutProductoInput = {
    precio?: FloatFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
    pedido?: PedidoUpdateOneRequiredWithoutDetallePedidosNestedInput
  }

  export type DetallePedidoUncheckedUpdateWithoutProductoInput = {
    id?: IntFieldUpdateOperationsInput | number
    precio?: FloatFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
    pedidoId?: IntFieldUpdateOperationsInput | number
  }

  export type DetallePedidoUncheckedUpdateManyWithoutDetallePedidosInput = {
    id?: IntFieldUpdateOperationsInput | number
    precio?: FloatFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
    pedidoId?: IntFieldUpdateOperationsInput | number
  }

  export type DireccionCreateManyUsuarioInput = {
    id?: number
    calle: string
    numero: string
    dpt: string
    ciudad: string
    provincia: string
    referencia?: string | null
  }

  export type PedidoCreateManyUsuarioInput = {
    id?: number
    montoTotal: number
    numeroSeguimiento?: string | null
    estado: PedidoEstado
    fecha: Date | string
    direccionId: number
  }

  export type DireccionUpdateWithoutUsuarioInput = {
    calle?: StringFieldUpdateOperationsInput | string
    numero?: StringFieldUpdateOperationsInput | string
    dpt?: StringFieldUpdateOperationsInput | string
    ciudad?: StringFieldUpdateOperationsInput | string
    provincia?: StringFieldUpdateOperationsInput | string
    referencia?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DireccionUncheckedUpdateWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    calle?: StringFieldUpdateOperationsInput | string
    numero?: StringFieldUpdateOperationsInput | string
    dpt?: StringFieldUpdateOperationsInput | string
    ciudad?: StringFieldUpdateOperationsInput | string
    provincia?: StringFieldUpdateOperationsInput | string
    referencia?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DireccionUncheckedUpdateManyWithoutDirecionesInput = {
    id?: IntFieldUpdateOperationsInput | number
    calle?: StringFieldUpdateOperationsInput | string
    numero?: StringFieldUpdateOperationsInput | string
    dpt?: StringFieldUpdateOperationsInput | string
    ciudad?: StringFieldUpdateOperationsInput | string
    provincia?: StringFieldUpdateOperationsInput | string
    referencia?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PedidoUpdateWithoutUsuarioInput = {
    montoTotal?: FloatFieldUpdateOperationsInput | number
    numeroSeguimiento?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EnumPedidoEstadoFieldUpdateOperationsInput | PedidoEstado
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    direccionId?: IntFieldUpdateOperationsInput | number
    DetallePedidos?: DetallePedidoUpdateManyWithoutPedidoNestedInput
    pedidoEventos?: PedidoEventoUpdateManyWithoutPedidoNestedInput
  }

  export type PedidoUncheckedUpdateWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    montoTotal?: FloatFieldUpdateOperationsInput | number
    numeroSeguimiento?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EnumPedidoEstadoFieldUpdateOperationsInput | PedidoEstado
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    direccionId?: IntFieldUpdateOperationsInput | number
    DetallePedidos?: DetallePedidoUncheckedUpdateManyWithoutPedidoNestedInput
    pedidoEventos?: PedidoEventoUncheckedUpdateManyWithoutPedidoNestedInput
  }

  export type PedidoUncheckedUpdateManyWithoutPedidosInput = {
    id?: IntFieldUpdateOperationsInput | number
    montoTotal?: FloatFieldUpdateOperationsInput | number
    numeroSeguimiento?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EnumPedidoEstadoFieldUpdateOperationsInput | PedidoEstado
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    direccionId?: IntFieldUpdateOperationsInput | number
  }

  export type DetallePedidoCreateManyPedidoInput = {
    id?: number
    precio: number
    cantidad: number
    productoId: number
  }

  export type PedidoEventoCreateManyPedidoInput = {
    id?: number
    titulo: PedidoEstado
    fecha: Date | string
  }

  export type DetallePedidoUpdateWithoutPedidoInput = {
    precio?: FloatFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
    producto?: ProductoUpdateOneRequiredWithoutDetallePedidosNestedInput
  }

  export type DetallePedidoUncheckedUpdateWithoutPedidoInput = {
    id?: IntFieldUpdateOperationsInput | number
    precio?: FloatFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
    productoId?: IntFieldUpdateOperationsInput | number
  }

  export type PedidoEventoUpdateWithoutPedidoInput = {
    titulo?: EnumPedidoEstadoFieldUpdateOperationsInput | PedidoEstado
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PedidoEventoUncheckedUpdateWithoutPedidoInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo?: EnumPedidoEstadoFieldUpdateOperationsInput | PedidoEstado
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PedidoEventoUncheckedUpdateManyWithoutPedidoEventosInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo?: EnumPedidoEstadoFieldUpdateOperationsInput | PedidoEstado
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}